{
    "name": "LeetCode \ud83c\udf43",
    "sections": [
        {
            "name": "\ud83d\udc4c Easy",
            "tasks": [
                {
                    "name": "Backspace String Compare",
                    "link": "https://leetcode.com/problems/backspace-string-compare",
                    "description": "<p>Given two&nbsp;strings&nbsp;<code>S</code>&nbsp;and <code>T</code>,&nbsp;return if they are equal when both are typed into empty text editors. <code>#</code> means a backspace character.</p>\n\n<p>Note that after&nbsp;backspacing an empty text, the text will continue empty.</p>\n\n<div>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input: </strong>S = <span id=\"example-input-1-1\">&quot;ab#c&quot;</span>, T = <span id=\"example-input-1-2\">&quot;ad#c&quot;</span>\n<strong>Output: </strong><span id=\"example-output-1\">true\n</span><span><strong>Explanation</strong>: Both S and T become &quot;ac&quot;.</span>\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input: </strong>S = <span id=\"example-input-2-1\">&quot;ab##&quot;</span>, T = <span id=\"example-input-2-2\">&quot;c#d#&quot;</span>\n<strong>Output: </strong><span id=\"example-output-2\">true\n</span><span><strong>Explanation</strong>: Both S and T become &quot;&quot;.</span>\n</pre>\n\n<div>\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input: </strong>S = <span id=\"example-input-3-1\">&quot;a##c&quot;</span>, T = <span id=\"example-input-3-2\">&quot;#a#c&quot;</span>\n<strong>Output: </strong><span id=\"example-output-3\">true\n</span><span><strong>Explanation</strong>: Both S and T become &quot;c&quot;.</span>\n</pre>\n\n<div>\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input: </strong>S = <span id=\"example-input-4-1\">&quot;a#c&quot;</span>, T = <span id=\"example-input-4-2\">&quot;b&quot;</span>\n<strong>Output: </strong><span id=\"example-output-4\">false\n</span><span><strong>Explanation</strong>: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</span>\n</pre>\n\n<p><span><strong>Note</strong>:</span></p>\n\n<ul>\n\t<li><code><span>1 &lt;= S.length &lt;= 200</span></code></li>\n\t<li><code><span>1 &lt;= T.length &lt;= 200</span></code></li>\n\t<li><span><code>S</code>&nbsp;and <code>T</code> only contain&nbsp;lowercase letters and <code>&#39;#&#39;</code> characters.</span></li>\n</ul>\n\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Can you solve it in <code>O(N)</code> time and <code>O(1)</code> space?</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    string translate(const string &inputS)\n    {\n        string S = inputS;\n        for(int i = 0; i < S.size(); ++i)\n        {\n            if(S[i] == '#')\n            {\n                if(i == 0)\n                {\n                    S.erase(i,1);\n                    i--;\n                }\n                else\n                {\n                    S.erase(i-1,2);\n                    i-=2;\n                }\n                                 \n            }\n        }\n        \n        return S;\n    }\n    bool backspaceCompare(string S, string T)\n    {\n        return translate(S) == translate(T);\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "backspace-string-compare",
                        "submissions": {
                            "cpp": "322075660"
                        }
                    }
                },
                {
                    "name": "Binary Search",
                    "link": "https://leetcode.com/problems/binary-search",
                    "description": "<p>Given a <strong>sorted</strong> (in ascending order) integer array <code>nums</code> of <code>n</code> elements and a <code>target</code> value, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index, otherwise return <code>-1</code>.</p>\r\n\r\n<p><br />\r\n<strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 9\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> 9 exists in <code>nums</code> and its index is 4\r\n\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 2\r\n<strong>Output:</strong> -1\r\n<strong>Explanation:</strong> 2 does not exist in <code>nums</code> so return -1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>You may assume that all elements in <code>nums</code> are unique.</li>\r\n\t<li><code>n</code> will be in the range <code>[1, 10000]</code>.</li>\r\n\t<li>The value of each element in <code>nums</code> will be in the range <code>[-9999, 9999]</code>.</li>\r\n</ol>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    //classic O(log n) dolution\n    int search(vector<int>& nums, int target)\n    {\n        if(nums.empty())\n            return -1;\n        //starting index is in the middle of the array\n        //step is the first step that will be applied\n        //step should be at least 1\n        for(size_t step = nums.size()/2, index = step;\n            nums.size() > index  && index >= 0;\n            )\n        {\n            //return index;\n            const int num = nums[index];\n            if(num == target)\n                return index;\n            \n            if(!step)\n                break;\n            step = (step+1) / 2;\n            if(num < target)\n                index += step;\n            else\n                index -= step;\n            if(step == 1)\n                step = 0;\n        }   \n        \n        return -1;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "binary-search",
                        "submissions": {
                            "cpp": "406294895"
                        }
                    }
                },
                {
                    "name": "Check If N and Its Double Exist",
                    "link": "https://leetcode.com/problems/check-if-n-and-its-double-exist",
                    "description": "<p>Given an array <code>arr</code> of integers, check if there exists two integers <code>N</code> and <code>M</code> such that <code>N</code> is the double of <code>M</code> ( i.e. <code>N = 2 * M</code>).</p>\n\n<p>More formally check if there exists&nbsp;two indices <code>i</code> and <code>j</code> such that :</p>\n\n<ul>\n\t<li><code>i != j</code></li>\n\t<li><code>0 &lt;= i, j &lt; arr.length</code></li>\n\t<li><code>arr[i] == 2 * arr[j]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [10,2,5,3]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> N<code> = 10</code> is the double of M<code> = 5</code>,that is, <code>10 = 2 * 5</code>.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [7,1,14,11]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> N<code> = 14</code> is the double of M<code> = 7</code>,that is, <code>14 = 2 * 7</code>.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [3,1,7,11]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> In this case does not exist N and M, such that N = 2 * M.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>-10^3 &lt;= arr[i] &lt;= 10^3</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#define all(x) (x).begin(), (x).end()\n\nclass Solution\n{\npublic:\n    bool checkIfExist(vector<int>& arr)\n    {\n        //O(n^2) solution\n        for(auto iter = begin(arr); iter < end(arr); ++iter)\n        {\n            auto found = find(all(arr), *iter*2);\n            if( found != arr.end() && found != iter)\n                return true;\n        }\n\n        return false;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "check-if-n-and-its-double-exist",
                        "submissions": {
                            "cpp": "399691070"
                        }
                    }
                },
                {
                    "name": "Complement of Base 10 Integer",
                    "link": "https://leetcode.com/problems/complement-of-base-10-integer",
                    "description": "<p>Every non-negative integer <code>N</code>&nbsp;has a binary representation.&nbsp; For example,&nbsp;<code>5</code> can be represented as <code>&quot;101&quot;</code>&nbsp;in binary, <code>11</code> as <code>&quot;1011&quot;</code>&nbsp;in binary, and so on.&nbsp; Note that except for <code>N = 0</code>, there are no leading zeroes in any&nbsp;binary representation.</p>\n\n<p>The <em>complement</em>&nbsp;of a binary representation&nbsp;is the number in binary you get when changing every <code>1</code> to a <code>0</code> and <code>0</code> to a <code>1</code>.&nbsp; For example, the complement of <code>&quot;101&quot;</code> in binary is <code>&quot;010&quot;</code> in binary.</p>\n\n<p>For a given number <code>N</code> in base-10, return the complement of it&#39;s binary representation as a&nbsp;base-10 integer.</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<div>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input: </strong><span id=\"example-input-1-1\">5</span>\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\n<strong>Explanation: </strong>5 is &quot;101&quot; in binary, with complement &quot;010&quot; in binary, which is 2 in base-10.\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input: </strong><span id=\"example-input-2-1\">7</span>\n<strong>Output: </strong><span id=\"example-output-2\">0</span>\n<span id=\"example-output-1\"><strong>Explanation: </strong>7 is &quot;111&quot; in binary, with complement &quot;000&quot; in binary, which is 0 in base-10.\n</span></pre>\n\n<div>\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input: </strong><span id=\"example-input-3-1\">10</span>\n<strong>Output: </strong><span id=\"example-output-3\">5</span>\n<strong>Explanation: </strong>10 is &quot;1010&quot; in binary, with complement &quot;0101&quot; in binary, which is 5 in base-10.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Note:</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= N &lt; 10^9</code></li>\n\t<li>This question is the same as 476:&nbsp;<a href=\"https://leetcode.com/problems/number-complement/\">https://leetcode.com/problems/number-complement/</a></li>\n</ol>\n</div>\n</div>\n</div>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    //O(1) solution\n    int bitwiseComplement(int N)\n    {\n        if(N == 0)\n            return 1;\n        //leading_zeros\n        const size_t LZ =  __builtin_clz(N); \n        return (~(N << LZ)) >> LZ;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "complement-of-base-10-integer",
                        "submissions": {
                            "cpp": "404751365"
                        }
                    }
                },
                {
                    "name": "Contains Duplicate",
                    "link": "https://leetcode.com/problems/contains-duplicate",
                    "description": "<p>Given an array of integers, find if the array contains any duplicates.</p>\r\n\r\n<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [1,2,3,1]\r\n<strong>Output:</strong> true</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[1,2,3,4]\r\n<strong>Output:</strong> false</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[1,1,1,3,3,4,3,2,4,2]\r\n<strong>Output:</strong> true</pre>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <algorithm>\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int> nums)\n    {\n        std::sort(nums.begin(), nums.end());\n\n        if(\n            nums.size()\n            ==\n            std::distance( nums.begin(), std::unique(nums.begin(), nums.end()) )\n        )\n            return false;\n        else\n            return true;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "contains-duplicate",
                        "submissions": {
                            "cpp": "297869264"
                        }
                    }
                },
                {
                    "name": "Defanging an IP Address",
                    "link": "https://leetcode.com/problems/defanging-an-ip-address",
                    "description": "<p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p>\r\n\r\n<p>A <em>defanged&nbsp;IP address</em>&nbsp;replaces every period <code>&quot;.&quot;</code> with <code>&quot;[.]&quot;</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n<pre><strong>Input:</strong> address = \"1.1.1.1\"\r\n<strong>Output:</strong> \"1[.]1[.]1[.]1\"\r\n</pre><p><strong>Example 2:</strong></p>\r\n<pre><strong>Input:</strong> address = \"255.100.50.0\"\r\n<strong>Output:</strong> \"255[.]100[.]50[.]0\"\r\n</pre>\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li>The given <code>address</code> is a valid IPv4 address.</li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    string defangIPaddr(string address)\n    {\n        string res;\n        \n        for_each(address.begin(), address.end(),\n                [&res](char c) \n                {\n                    if(c == '.')\n                        res+=\"[.]\";\n                    else\n                        res.push_back(c);\n                });\n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "defanging-an-ip-address",
                        "submissions": {
                            "cpp": "388475509"
                        }
                    }
                },
                {
                    "name": "Delete Node in a Linked List",
                    "link": "https://leetcode.com/problems/delete-node-in-a-linked-list",
                    "description": "<p>Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p>\n\n<p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" style=\"width: 450px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> head = [4,5,1,9], node = 5\n<strong>Output:</strong> [4,1,9]\n<strong>Explanation: </strong>You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" style=\"width: 450px; height: 354px;\" />\n<pre>\n<strong>Input:</strong> head = [4,5,1,9], node = 1\n<strong>Output:</strong> [4,5,9]\n<strong>Explanation: </strong>You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2,3,4], node = 3\n<strong>Output:</strong> [1,2,4]\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [0,1], node = 0\n<strong>Output:</strong> [1]\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [-3,5,-99], node = -3\n<strong>Output:</strong> [5,-99]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>The value of each node in the list is <strong>unique</strong>.</li>\n\t<li>The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node)\n    {\n        node->val = node->next->val;\n        auto *redundant_next = node->next;\n        node->next = node->next->next;\n        delete redundant_next;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "delete-node-in-a-linked-list",
                        "submissions": {
                            "cpp": "348044742"
                        }
                    }
                },
                {
                    "name": "Duplicate Zeros",
                    "link": "https://leetcode.com/problems/duplicate-zeros",
                    "description": "<p>Given a fixed length&nbsp;array <code>arr</code> of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.</p>\r\n\r\n<p>Note that elements beyond the length of the original array are not written.</p>\r\n\r\n<p>Do the above modifications to the input array <strong>in place</strong>, do not return anything from your function.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,0,2,3,0,4,5,0]</span>\r\n<strong>Output: </strong>null\r\n<strong>Explanation: </strong>After calling your function, the <strong>input</strong> array is modified to: <span id=\"example-output-1\">[1,0,0,2,3,0,0,4]</span>\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,2,3]</span>\r\n<strong>Output: </strong>null\r\n<strong>Explanation: </strong>After calling your function, the <strong>input</strong> array is modified to: <span id=\"example-output-2\">[1,2,3]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= arr.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= arr[i] &lt;= 9</code></li>\r\n</ol>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\n    template<typename T>\n    void insert_stable_size(size_t pos, T val, vector<T> &arr)\n    {\n        for(size_t i = pos; i < arr.size(); ++i)\n        {\n            std::swap(val, arr[i]);\n        }\n    }\npublic:\n    void duplicateZeros(vector<int>& arr)\n    {\n        //I am not using insert + pop_back\n        //because the goal if the task is to do it manually\n        for(size_t i = 0; i < arr.size()-1; ++i)\n        {\n            if(arr[i] == 0)\n            {\n                insert_stable_size(i+1, 0, arr);\n                //skip inserted 0\n                ++i;\n            }\n        }\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "duplicate-zeros",
                        "submissions": {
                            "cpp": "399676730"
                        }
                    }
                },
                {
                    "name": "Excel Sheet Column Number",
                    "link": "https://leetcode.com/problems/excel-sheet-column-number",
                    "description": "<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>\r\n\r\n<p>For example:</p>\r\n\r\n<pre>\r\n    A -&gt; 1\r\n    B -&gt; 2\r\n    C -&gt; 3\r\n    ...\r\n    Z -&gt; 26\r\n    AA -&gt; 27\r\n    AB -&gt; 28 \r\n    ...\r\n</pre>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> &quot;A&quot;\r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;AB&quot;\r\n<strong>Output:</strong> 28\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;ZY&quot;\r\n<strong>Output:</strong> 701\r\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 7</code></li>\n\t<li><code>s</code> consists only of uppercase English letters.</li>\n\t<li><code>s</code> is between &quot;A&quot; and &quot;FXSHRXW&quot;.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    int titleToNumber(string s)\n    {\n        int res = 0;\n        int index = 0;\n        for(auto riter = s.rbegin(); riter != s.rend(); ++riter, ++index)\n            res+= (*riter-'A'+1)*std::pow(26,index);\n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "excel-sheet-column-number",
                        "submissions": {
                            "cpp": "378803388"
                        }
                    }
                },
                {
                    "name": "Find All Numbers Disappeared in an Array",
                    "link": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array",
                    "description": "<p>Given an array of integers where 1 &le; a[i] &le; <i>n</i> (<i>n</i> = size of array), some elements appear twice and others appear once.</p>\r\n\r\n<p>Find all the elements of [1, <i>n</i>] inclusive that do not appear in this array.</p>\r\n\r\n<p>Could you do it without extra space and in O(<i>n</i>) runtime? You may assume the returned list does not count as extra space.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n<b>Input:</b>\r\n[4,3,2,7,8,2,3,1]\r\n\r\n<b>Output:</b>\r\n[5,6]\r\n</pre>\r\n</p>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums)\n    {\n        set<int> all_nums;\n        for(int i = 1; i <= nums.size(); ++i)\n            all_nums.insert(i);\n        \n        for(auto num : nums)\n            all_nums.erase(num);\n        \n        return vector<int>(begin(all_nums),end(all_nums));    \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "find-all-numbers-disappeared-in-an-array",
                        "submissions": {
                            "cpp": "400106274"
                        }
                    }
                },
                {
                    "name": "Find Numbers with Even Number of Digits",
                    "link": "https://leetcode.com/problems/find-numbers-with-even-number-of-digits",
                    "description": "Given an array <code>nums</code> of integers, return how many of them contain an <strong>even number</strong> of digits.\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,345,2,6,7896]\n<strong>Output:</strong> 2\n<strong>Explanation: \n</strong>12 contains 2 digits (even number of digits).&nbsp;\n345 contains 3 digits (odd number of digits).&nbsp;\n2 contains 1 digit (odd number of digits).&nbsp;\n6 contains 1 digit (odd number of digits).&nbsp;\n7896 contains 4 digits (even number of digits).&nbsp;\nTherefore only 12 and 7896 contain an even number of digits.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [555,901,482,1771]\n<strong>Output:</strong> 1 \n<strong>Explanation: </strong>\nOnly 1771 contains an even number of digits.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <limits>\n\nclass Solution\n{\npublic:\n    int findNumbers(vector<int>& nums)\n    {\n        int res = 0;\n        for(int num : nums)\n        for(int i = 1, is_even = 1;\n            i < std::numeric_limits<int>::max();\n            i*=10, is_even=!is_even)\n        {\n            if(num/i == 0)\n            {\n                if(is_even)\n                    res++;\n                break;\n            }\n                \n        }\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "find-numbers-with-even-number-of-digits",
                        "submissions": {
                            "cpp": "397966980"
                        }
                    }
                },
                {
                    "name": "Find the Difference",
                    "link": "https://leetcode.com/problems/find-the-difference",
                    "description": "<p>You are given two strings <code>s</code> and <code>t</code>.</p>\n\n<p>String <code>t</code> is generated by random shuffling string <code>s</code> and then add one more letter at a random position.</p>\n\n<p>Return the letter that was added to <code>t</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;abcde&quot;\n<strong>Output:</strong> &quot;e&quot;\n<strong>Explanation:</strong> &#39;e&#39; is the letter that was added.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;, t = &quot;y&quot;\n<strong>Output:</strong> &quot;y&quot;\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>Output:</strong> &quot;a&quot;\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ae&quot;, t = &quot;aea&quot;\n<strong>Output:</strong> &quot;a&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>t.length == s.length + 1</code></li>\n\t<li><code>s</code> and <code>t</code> consist of lower-case English letters.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#define all(x) (x).begin(), (x).end()\nclass Solution\n{\n\npublic:\n    char findTheDifference(string s, string t)\n    {\n        std::sort(all(s));\n        std::sort(all(t));\n        \n        string diff;\n        std::set_difference(all(t),\n                            all(s),\n                            back_inserter(diff));\n\n        return diff.front();\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "find-the-difference",
                        "submissions": {
                            "cpp": "400048665"
                        }
                    }
                },
                {
                    "name": "First Unique Character in a String",
                    "link": "https://leetcode.com/problems/first-unique-character-in-a-string",
                    "description": "<p>Given a string, find the first non-repeating character in it and return its index. If it doesn&#39;t exist, return -1.</p>\n\n<p><b>Examples:</b></p>\n\n<pre>\ns = &quot;leetcode&quot;\nreturn 0.\n\ns = &quot;loveleetcode&quot;\nreturn 2.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>Note:</b> You may assume the string contains only lowercase English letters.</p>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <algorithm>\n\nclass Solution {\npublic:\n    int firstUniqChar(string s)\n    {\n        int first_bitmask = 0, second_bitmask = 0;\n        for(auto iter = s.begin(); iter != s.end(); ++iter)\n        {\n            if(! (first_bitmask & 1 << (*iter - 'a')) )\n               first_bitmask |= 1 << *iter - 'a';\n            else if(! (second_bitmask & 1 << (*iter - 'a')) )\n               second_bitmask |= 1 << *iter - 'a';\n        }\n        \n        for(int i = 0; i< s.size(); ++i)\n            if( first_bitmask & 1 << (s[i] - 'a') \n               && !(second_bitmask & 1 << (s[i] - 'a')) )\n                    return i;\n        return -1;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "first-unique-character-in-a-string",
                        "submissions": {
                            "cpp": "302370158"
                        }
                    }
                },
                {
                    "name": "Fizz Buzz",
                    "link": "https://leetcode.com/problems/fizz-buzz",
                    "description": "<p>Write a program that outputs the string representation of numbers from 1 to <i>n</i>.</p>\r\n\r\n<p>But for multiples of three it should output \u201cFizz\u201d instead of the number and for the multiples of five output \u201cBuzz\u201d. For numbers which are multiples of both three and five output \u201cFizzBuzz\u201d.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nn = 15,\r\n\r\nReturn:\r\n[\r\n    \"1\",\r\n    \"2\",\r\n    \"Fizz\",\r\n    \"4\",\r\n    \"Buzz\",\r\n    \"Fizz\",\r\n    \"7\",\r\n    \"8\",\r\n    \"Fizz\",\r\n    \"Buzz\",\r\n    \"11\",\r\n    \"Fizz\",\r\n    \"13\",\r\n    \"14\",\r\n    \"FizzBuzz\"\r\n]\r\n</pre>\r\n</p>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    vector<string> fizzBuzz(int n)\n    {\n        vector<string> res;\n        for(size_t i = 1; i<=n; ++i)\n        {\n            string fb = \"\";\n            if(!(i%3))\n                fb+=\"Fizz\";\n            if(!(i%5))\n                fb+=\"Buzz\";\n            if(fb.empty())\n                fb = std::to_string(i);\n            \n            res.push_back(fb);\n        }\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "fizz-buzz",
                        "submissions": {
                            "cpp": "378980701"
                        }
                    }
                },
                {
                    "name": "Goat Latin",
                    "link": "https://leetcode.com/problems/goat-latin",
                    "description": "<p>A sentence <code>S</code> is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p>\r\n\r\n<p>We would like to convert the sentence to &quot;<em>Goat Latin&quot;</em>&nbsp;(a made-up language similar to Pig Latin.)</p>\r\n\r\n<p>The rules of Goat Latin are as follows:</p>\r\n\r\n<ul>\r\n\t<li>If a word begins with a vowel (a, e, i, o, or u), append <code>&quot;ma&quot;</code>&nbsp;to the end of the word.<br />\r\n\tFor example, the word &#39;apple&#39; becomes &#39;applema&#39;.<br />\r\n\t&nbsp;</li>\r\n\t<li>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add <code>&quot;ma&quot;</code>.<br />\r\n\tFor example, the word <code>&quot;goat&quot;</code>&nbsp;becomes <code>&quot;oatgma&quot;</code>.<br />\r\n\t&nbsp;</li>\r\n\t<li>Add one letter <code>&#39;a&#39;</code>&nbsp;to the end of each word per its word index in the sentence, starting with 1.<br />\r\n\tFor example,&nbsp;the first word gets <code>&quot;a&quot;</code> added to the end, the second word gets <code>&quot;aa&quot;</code> added to the end and so on.</li>\r\n</ul>\r\n\r\n<p>Return the&nbsp;final sentence representing the conversion from <code>S</code>&nbsp;to Goat&nbsp;Latin.&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;I speak Goat Latin&quot;\r\n<strong>Output: </strong>&quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>&quot;The quick brown fox jumped over the lazy dog&quot;\r\n<strong>Output: </strong>&quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Notes:</p>\r\n\r\n<ul>\r\n\t<li><code>S</code> contains only uppercase, lowercase and spaces.&nbsp;Exactly one space between each word.</li>\r\n\t<li><code>1 &lt;= S.length &lt;= 150</code>.</li>\r\n</ul>\r\n",
                    "solutions": {
                        "python": [
                            {
                                "language": "python",
                                "code": "class Solution:\n    def toGoatLatin(self, S: str) -> str:\n        return \" \".join([ (s if s[0] in \"aeiouAEIOU\" else s[1:]+s[0])+'ma'+'a'*(i+1)  for i,s in enumerate(S.split(' ')) ])\n        "
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "goat-latin",
                        "submissions": {
                            "python": "383227811"
                        }
                    }
                },
                {
                    "name": "Height Checker",
                    "link": "https://leetcode.com/problems/height-checker",
                    "description": "<p>Students are asked to stand in non-decreasing order of heights for an annual photo.</p>\n\n<p>Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.</p>\n\n<p>Notice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students&nbsp;remain on their seats.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> heights = [1,1,4,2,1,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> heights = [5,1,2,3,4]\n<strong>Output:</strong> 5\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> heights = [1,2,3,4,5]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 100</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#define all(x) (x).begin(), (x).end()\nclass Solution\n{\npublic:\n    int heightChecker(vector<int>& heights)\n    {\n        //O(N logN) solution (sorting)\n        vector<int> sorted_h = heights;\n        std::sort(all(sorted_h));\n                \n        unsigned counter = 0;\n        for(int i = 0; i < heights.size(); ++i)\n            if(heights[i] != sorted_h[i])\n                ++counter;    \n        \n        return counter;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "height-checker",
                        "submissions": {
                            "cpp": "400099905"
                        }
                    }
                },
                {
                    "name": "Intersection of Two Arrays II",
                    "link": "https://leetcode.com/problems/intersection-of-two-arrays-ii",
                    "description": "<p>Given two arrays, write a function to compute their intersection.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums1 = <span id=\"example-input-1-1\">[1,2,2,1]</span>, nums2 = <span id=\"example-input-1-2\">[2,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[2,2]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>nums1 = <span id=\"example-input-2-1\">[4,9,5]</span>, nums2 = <span id=\"example-input-2-2\">[9,4,9,8,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[4,9]</span></pre>\r\n</div>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>Each element in the result should appear as many times as it shows in both arrays.</li>\r\n\t<li>The result can be in any order.</li>\r\n</ul>\r\n\r\n<p><b>Follow up:</b></p>\r\n\r\n<ul>\r\n\t<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\r\n\t<li>What if <i>nums1</i>&#39;s size is small compared to <i>nums2</i>&#39;s size? Which algorithm is better?</li>\r\n\t<li>What if elements of <i>nums2</i> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\r\n</ul>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <algorithm>\nusing std::count;\n\nclass Solution\n{\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2)\n    {\n        bool is_firstbigger = nums1.size() > nums2.size();\n        vector<int> res,\n            &big = is_firstbigger ? nums1 : nums2,\n            &small = is_firstbigger ? nums2 : nums1;\n\n        \n        \n        for(int i = 0; i < small.size(); ++i)\n        {\n            int b_element = small[i],  \n                count_in_big = count(big.begin(), big.end(), b_element);\n            \n            if(count_in_big > 0 && count(res.begin(), res.end(), b_element) == 0)\n            {\n                int count_in_small = count(small.begin(), small.end(), b_element);\n                res.insert(res.begin(), std::min(count_in_big, count_in_small), b_element);\n            }   \n        }\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "intersection-of-two-arrays-ii",
                        "submissions": {
                            "cpp": "301709226"
                        }
                    }
                },
                {
                    "name": "Invert Binary Tree",
                    "link": "https://leetcode.com/problems/invert-binary-tree",
                    "description": "<p>Invert a binary tree.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Input:</p>\r\n\r\n<pre>\r\n     4\r\n   /   \\\r\n  2     7\r\n / \\   / \\\r\n1   3 6   9</pre>\r\n\r\n<p>Output:</p>\r\n\r\n<pre>\r\n     4\r\n   /   \\\r\n  7     2\r\n / \\   / \\\r\n9   6 3   1</pre>\r\n\r\n<p><strong>Trivia:</strong><br />\r\nThis problem was inspired by <a href=\"https://twitter.com/mxcl/status/608682016205344768\" target=\"_blank\">this original tweet</a> by <a href=\"https://twitter.com/mxcl\" target=\"_blank\">Max Howell</a>:</p>\r\n\r\n<blockquote>Google: 90% of our engineers use the software you wrote (Homebrew), but you can&rsquo;t invert a binary tree on a whiteboard so f*** off.</blockquote>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root)\n    {\n        if(!root) return nullptr;\n        std::swap(root->left, root->right);\n        invertTree(root->left);\n        invertTree(root->right);\n        return root;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "invert-binary-tree",
                        "submissions": {
                            "cpp": "363432168"
                        }
                    }
                },
                {
                    "name": "Kids With the Greatest Number of Candies",
                    "link": "https://leetcode.com/problems/kids-with-the-greatest-number-of-candies",
                    "description": "<p>Given the array <code>candies</code> and the integer <code>extraCandies</code>, where <code>candies[i]</code> represents the number of candies that the <strong><em>ith</em></strong> kid has.</p>\r\n\r\n<p>For each kid check if there is a way to distribute <code>extraCandies</code> among the kids such that he or she can have the <strong>greatest</strong> number of candies among them.&nbsp;Notice that multiple kids can have the <strong>greatest</strong> number of candies.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> candies = [2,3,5,1,3], extraCandies = 3\r\n<strong>Output:</strong> [true,true,true,false,true] \r\n<strong>Explanation:</strong> \r\nKid 1 has 2 candies and if he or she receives all extra candies (3) will have 5 candies --- the greatest number of candies among the kids. \r\nKid 2 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids. \r\nKid 3 has 5 candies and this is already the greatest number of candies among the kids. \r\nKid 4 has 1 candy and even if he or she receives all extra candies will only have 4 candies. \r\nKid 5 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids. \r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> candies = [4,2,1,1,2], extraCandies = 1\r\n<strong>Output:</strong> [true,false,false,false,false] \r\n<strong>Explanation:</strong> There is only 1 extra candy, therefore only kid 1 will have the greatest number of candies among the kids regardless of who takes the extra candy.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> candies = [12,1,12], extraCandies = 10\r\n<strong>Output:</strong> [true,false,true]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>2 &lt;= candies.length &lt;= 100</code></li>\r\n\t<li><code>1 &lt;= candies[i] &lt;= 100</code></li>\r\n\t<li><code>1 &lt;= extraCandies &lt;= 50</code></li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies)\n    {\n        vector<bool> res;\n        res.reserve(candies.size());\n            \n        int max_candies = *std::max_element(candies.begin(), candies.end());\n        for(auto &c : candies)\n            res.emplace_back( (c + extraCandies) >= max_candies);\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "kids-with-the-greatest-number-of-candies",
                        "submissions": {
                            "cpp": "380298193"
                        }
                    }
                },
                {
                    "name": "Length of Last Word",
                    "link": "https://leetcode.com/problems/length-of-last-word",
                    "description": "<p>Given a string <i>s</i> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.</p>\n\n<p>If the last word does not exist, return 0.</p>\n\n<p><b>Note:</b> A word is defined as a <strong>maximal substring</strong> consisting&nbsp;of non-space characters only.</p>\n\n<p><b>Example:</b></p>\n\n<pre>\n<b>Input:</b> &quot;Hello World&quot;\n<b>Output:</b> 5\n</pre>\n\n<p>&nbsp;</p>\n",
                    "solutions": {
                        "python": [
                            {
                                "language": "python",
                                "code": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        return len(s.rsplit(maxsplit=1)[-1]) if len(s.strip()) else 0\n        "
                            }
                        ],
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    int lengthOfLastWord(string s)\n    {\n        int counter = 0;\n        auto riter = s.rbegin();\n        for(; *riter == ' '; riter++);\n        for(; *riter!=' ' && riter!=s.rend(); riter++, counter++);\n        return counter;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "length-of-last-word",
                        "submissions": {
                            "python": "397369817",
                            "cpp": "378523512"
                        }
                    }
                },
                {
                    "name": "Longest Common Prefix",
                    "link": "https://leetcode.com/problems/longest-common-prefix",
                    "description": "<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\r\n\r\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\r\n<strong>Output:</strong> &quot;fl&quot;\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>[&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\r\n<strong>Output:</strong> &quot;&quot;\r\n<strong>Explanation:</strong> There is no common prefix among the input strings.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>All given inputs are in lowercase letters <code>a-z</code>.</p>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    string longestCommonPrefix(vector<string>& strs)\n    {\n        if(strs.empty())\n            return \"\";\n        \n        string res = \"\";  \n        bool keep_going = true;\n        size_t first_str_size = strs[0].size(); \n        for(size_t i = 0; keep_going && i < first_str_size; i++)\n        {\n            char ch = strs[0][i];\n            \n            for(auto &str : strs)\n                if(str.size() <= i || str[i] != ch)\n                    keep_going = false;\n            \n            if(keep_going)\n                res+=ch;      \n        }\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "longest-common-prefix",
                        "submissions": {
                            "cpp": "378513785"
                        }
                    }
                },
                {
                    "name": "Max Consecutive Ones",
                    "link": "https://leetcode.com/problems/max-consecutive-ones",
                    "description": "<p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [1,1,0,1,1,1]\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> The first two digits or the last three digits are consecutive 1s.\r\n    The maximum number of consecutive 1s is 3.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b>\r\n<ul>\r\n<li>The input array will only contain <code>0</code> and <code>1</code>.</li>\r\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\r\n</ul>\r\n</p>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    int findMaxConsecutiveOnes(vector<int>& nums)\n    {\n        int res = 0, local_max = 0;\n        for(auto n : nums)\n        {\n            if(!n)\n                local_max=0;\n            else if(local_max++ == res)\n                ++res;\n        }\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "max-consecutive-ones",
                        "submissions": {
                            "cpp": "353722934"
                        }
                    }
                },
                {
                    "name": "Maximum Depth of Binary Tree",
                    "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree",
                    "description": "<p>Given a binary tree, find its maximum depth.</p>\r\n\r\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>\r\n\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7</pre>\r\n\r\n<p>return its depth = 3.</p>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\n#include <algorithm>\nusing std::max;\n\nclass Solution\n{\npublic:\n    int maxDepth(TreeNode* root) \n    {\n        if(!root)\n            return 0;\n\n        //leaf\n        if(!root->left && !root->right)\n            return 1;\n        int \n         l_depth = maxDepth(root->left),\n         r_depth = maxDepth(root->right);\n        \n        return max(l_depth+1,r_depth+1);\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "maximum-depth-of-binary-tree",
                        "submissions": {
                            "cpp": "296206624"
                        }
                    }
                },
                {
                    "name": "Merge Sorted Array",
                    "link": "https://leetcode.com/problems/merge-sorted-array",
                    "description": "<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>\n\t<li>You may assume that <em>nums1</em> has enough space (size that is&nbsp;<strong>equal</strong> to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li>\n</ul>\n\n<p><strong>Example:</strong></p>\n\n<pre>\n<strong>Input:</strong>\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\n<strong>Output:</strong>&nbsp;[1,2,2,3,5,6]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)\n    {\n        if(!n)\n            return;\n        if(!m)\n        {\n            nums1 = nums2;\n            return;\n        }\n\n        //merge two sorted arrays in one\n        auto n1_iter = nums1.begin(),\n             n1_end = n1_iter + m,\n             n2_iter = nums2.begin(),\n             n2_end = n2_iter + n;\n        \n        vector<int> res;\n        res.reserve(n+m);\n        \n        while(n1_iter != n1_end && n2_iter != n2_end)\n        if(*n1_iter <  *n2_iter)\n        {\n            res.push_back(*n1_iter);\n            n1_iter++;\n            if(n1_iter == n1_end)\n                res.insert(end(res), n2_iter, n2_end);\n        }\n        else\n        {\n            res.push_back(*n2_iter);\n            n2_iter++;\n            if(n2_iter == n2_end)\n                res.insert(end(res), n1_iter, n1_end);\n        }\n        \n        nums1 = std::move(res);\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "merge-sorted-array",
                        "submissions": {
                            "cpp": "399682969"
                        }
                    }
                },
                {
                    "name": "Merge Two Sorted Lists",
                    "link": "https://leetcode.com/problems/merge-two-sorted-lists",
                    "description": "<p>Merge two sorted linked lists and return it as a new <strong>sorted</strong> list. The new list should be made by splicing together the nodes of the first two lists.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\" style=\"width: 662px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> l1 = [1,2,4], l2 = [1,3,4]\n<strong>Output:</strong> [1,1,2,3,4,4]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [], l2 = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [], l2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>Both <code>l1</code> and <code>l2</code> are sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution\n{\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)\n    {\n        //input validation\n        if(!l1 && !l2)\n            return nullptr;\n        if(!l1)\n            return l2;\n        if(!l2)\n            return l1;\n        \n        //init of vars\n        ListNode *&min_val_node = l1->val < l2->val ? l1 : l2;\n        const int start_val = min_val_node->val;\n        min_val_node = min_val_node->next;\n        \n        ListNode *new_list_start = new ListNode(start_val),\n                 *new_list_iter = new_list_start;\n        \n        //O(n) solution, two pointers\n        //while we have somthing in lists - merge them\n        while(l1 || l2)\n        {\n            if(l2 == nullptr || (l1 && l1->val < l2->val)) \n            {\n                new_list_iter->next = new ListNode(l1->val);\n                new_list_iter = new_list_iter->next;\n                l1 = l1->next;\n            }\n            else\n            {\n                new_list_iter->next = new ListNode(l2->val);\n                new_list_iter = new_list_iter->next;\n                l2 = l2->next;\n            }\n        }\n        \n        return new_list_start;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "merge-two-sorted-lists",
                        "submissions": {
                            "cpp": "404075398"
                        }
                    }
                },
                {
                    "name": "Middle of the Linked List",
                    "link": "https://leetcode.com/problems/middle-of-the-linked-list",
                    "description": "<p>Given a non-empty, singly&nbsp;linked list with head node <code>head</code>, return&nbsp;a&nbsp;middle node of linked list.</p>\r\n\r\n<p>If there are two middle nodes, return the second middle node.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,2,3,4,5]</span>\r\n<strong>Output: </strong>Node 3 from this list (Serialization: <span id=\"example-output-1\">[3,4,5]</span>)\r\nThe returned node has value 3.  (The judge&#39;s serialization of this node is [3,4,5]).\r\nNote that we returned a ListNode object ans, such that:\r\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[1,2,3,4,5,6]</span>\r\n<strong>Output: </strong>Node 4 from this list (Serialization: <span id=\"example-output-2\">[4,5,6]</span>)\r\nSince the list has two middle nodes with values 3 and 4, we return the second one.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of nodes in the given list will be between <code>1</code>&nbsp;and <code>100</code>.</li>\r\n</ul>\r\n</div>\r\n</div>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head)\n    {\n        if(!head)\n            return nullptr;\n            \n        size_t list_size = 1;\n        for(ListNode *node = head; node->next; node = node->next, ++list_size);\n        \n        unsigned res_index = list_size/2 + 1;\n        ListNode *res_node = head;\n        for(int i = 1; i < res_index; ++i)\n            res_node = res_node->next;\n        \n        return res_node;\n      \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "middle-of-the-linked-list",
                        "submissions": {
                            "cpp": "348381372"
                        }
                    }
                },
                {
                    "name": "Move Zeroes",
                    "link": "https://leetcode.com/problems/move-zeroes",
                    "description": "<p>Given an array <code>nums</code>, write a function to move all <code>0</code>&#39;s to the end of it while maintaining the relative order of the non-zero elements.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[0,1,0,3,12]</code>\r\n<b>Output:</b> <code>[1,3,12,0,0]</code></pre>\r\n\r\n<p><b>Note</b>:</p>\r\n\r\n<ol>\r\n\t<li>You must do this <b>in-place</b> without making a copy of the array.</li>\r\n\t<li>Minimize the total number of operations.</li>\r\n</ol>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <algorithm>\n\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums)\n    {\n        unsigned num0 = std::count(nums.begin(), nums.end(), 0);\n        std::remove_if(nums.begin(), nums.end(), [](int a){if(a == 0) return true; return false;});\n        std::fill(nums.end() - num0, nums.end(), 0);\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "move-zeroes",
                        "submissions": {
                            "cpp": "301715683"
                        }
                    }
                },
                {
                    "name": "Number of 1 Bits",
                    "link": "https://leetcode.com/problems/number-of-1-bits",
                    "description": "<p>Write a function that takes an unsigned integer and returns&nbsp;the number of &#39;1&#39;&nbsp;bits it has (also known as the <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\">Hamming weight</a>).</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer&#39;s internal binary representation is the same, whether it is signed or unsigned.</li>\n\t<li>In Java,&nbsp;the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">2&#39;s complement notation</a>. Therefore, in <strong>Example 3</strong>&nbsp;above, the input represents the signed integer.&nbsp;<code>-3</code>.</li>\n</ul>\n\n<p><b>Follow up</b>: If this function is called many times, how would you optimize it?</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 00000000000000000000000000001011\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The input binary string <strong>00000000000000000000000000001011</strong> has a total of three &#39;1&#39; bits.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 00000000000000000000000010000000\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The input binary string <strong>00000000000000000000000010000000</strong> has a total of one &#39;1&#39; bit.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 11111111111111111111111111111101\n<strong>Output:</strong> 31\n<strong>Explanation:</strong> The input binary string <strong>11111111111111111111111111111101</strong> has a total of thirty one &#39;1&#39; bits.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The input must be a <strong>binary string</strong> of length <code>32</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    int hammingWeight(uint32_t n)\n    {\n        return __builtin_popcount(n);\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "number-of-1-bits",
                        "submissions": {
                            "cpp": "405198655"
                        }
                    }
                },
                {
                    "name": "Number of Good Pairs",
                    "link": "https://leetcode.com/problems/number-of-good-pairs",
                    "description": "<p>Given an array of integers&nbsp;<code>nums</code>.</p>\r\n\r\n<p>A pair&nbsp;<code>(i,j)</code>&nbsp;is called <em>good</em> if&nbsp;<code>nums[i]</code> == <code>nums[j]</code> and <code>i</code> &lt; <code>j</code>.</p>\r\n\r\n<p>Return the number of <em>good</em> pairs.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,1,1,3]\r\n<strong>Output:</strong> 4\r\n<strong>Explanation: </strong>There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,1,1]\r\n<strong>Output:</strong> 6\r\n<strong>Explanation: </strong>Each pair in the array are <em>good</em>.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3]\r\n<strong>Output:</strong> 0\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    int numIdenticalPairs(vector<int>& nums)\n    {\n        size_t counter = 0;\n        for(auto iter = nums.begin(); iter != nums.end(); ++iter)\n            counter += std::count(std::next(iter), nums.end(), *iter);\n\n        return counter;\n            \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "number-of-good-pairs",
                        "submissions": {
                            "cpp": "378757588"
                        }
                    }
                },
                {
                    "name": "Number of Recent Calls",
                    "link": "https://leetcode.com/problems/number-of-recent-calls",
                    "description": "<p>You have a <code>RecentCounter</code> class which counts the number of recent requests within a certain time frame.</p>\n\n<p>Implement the <code>RecentCounter</code> class:</p>\n\n<ul>\n\t<li><code>RecentCounter()</code> Initializes the counter with zero recent requests.</li>\n\t<li><code>int ping(int t)</code> Adds a new request at time <code>t</code>, where <code>t</code> represents some time in milliseconds, and returns the number of requests that has happened in the past <code>3000</code> milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range <code>[t - 3000, t]</code>.</li>\n</ul>\n\n<p>It is <strong>guaranteed</strong> that every call to <code>ping</code> uses a strictly larger value of <code>t</code> than the previous call.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]\n[[], [1], [100], [3001], [3002]]\n<strong>Output</strong>\n[null, 1, 2, 3, 3]\n\n<strong>Explanation</strong>\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [<u>1</u>], range is [-2999,1], return 1\nrecentCounter.ping(100);   // requests = [<u>1</u>, <u>100</u>], range is [-2900,100], return 2\nrecentCounter.ping(3001);  // requests = [<u>1</u>, <u>100</u>, <u>3001</u>], range is [1,3001], return 3\nrecentCounter.ping(3002);  // requests = [1, <u>100</u>, <u>3001</u>, <u>3002</u>], range is [2,3002], return 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= t &lt;= 10<sup>9</sup></code></li>\n\t<li>Each test case will call <code>ping</code> with <strong>strictly increasing</strong> values of <code>t</code>.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>ping</code>.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class RecentCounter\n{\n    list<int> pings;\n\npublic:\n    RecentCounter() = default;\n    \n    int ping(int t)\n    {\n        \n        for(auto iter = pings.begin(); iter != pings.end();)\n        {\n            if(t-*iter > 3000)\n                iter = pings.erase(iter);\n            else\n                iter++;\n        }\n        pings.push_front(t);\n        \n        return pings.size();\n        \n    }\n};\n\n/**\n * Your RecentCounter object will be instantiated and called as such:\n * RecentCounter* obj = new RecentCounter();\n * int param_1 = obj->ping(t);\n */"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "number-of-recent-calls",
                        "submissions": {
                            "cpp": "403421491"
                        }
                    }
                },
                {
                    "name": "Palindrome Number",
                    "link": "https://leetcode.com/problems/palindrome-number",
                    "description": "<p>Determine whether an integer is a palindrome. An integer&nbsp;is&nbsp;a&nbsp;palindrome when it&nbsp;reads the same backward as forward.</p>\n\n<p><strong>Follow up:</strong> Could you solve&nbsp;it without converting the integer to a string?</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 121\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -121\n<strong>Output:</strong> false\n<strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 10\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -101\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    bool isPalindrome(int x)\n    {\n        //negative is not palindrome\n        if(x < 0)\n            return false;\n        if(x == 0)\n            return true;\n        //if last number is 0 it is not a polindrome\n        if(x%10 == 0)\n            return false;\n\n        //O(1) space\n        long reversed = 0;\n             \n        for(long mod = 10, div = 1;\n            reversed < x;\n            mod *= 10, div *= 10)\n        {\n            //put last character as first on reversed, and so on\n            reversed = reversed*10 + (x%mod)/div;\n        }\n        \n        return reversed == x;\n\n        //STRING SOLUTION O(N) space\n        /*\n        string num = std::to_string(x);\n        const size_t num_len = num.size();\n        for(size_t i = 0; i < num_len/2; ++i)\n            if(num[i] != num[num_len-1-i])\n                return false;        \n        return true;\n        */\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "palindrome-number",
                        "submissions": {
                            "cpp": "401340457"
                        }
                    }
                },
                {
                    "name": "Pascal's Triangle II",
                    "link": "https://leetcode.com/problems/pascals-triangle-ii",
                    "description": "<p>Given an integer <code>rowIndex</code>, return the <code>rowIndex<sup>th</sup></code>&nbsp;row of the Pascal&#39;s triangle.</p>\n\n<p>Notice&nbsp;that the row index starts from&nbsp;<strong>0</strong>.</p>\n\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" /><br />\n<small>In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it.</small></p>\n\n<p><strong>Follow up:</strong></p>\n\n<p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 3\n<strong>Output:</strong> [1,3,3,1]\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 0\n<strong>Output:</strong> [1]\n</pre><p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 1\n<strong>Output:</strong> [1,1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;=&nbsp;rowIndex &lt;= 40</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    vector<int> getRow(int rowIndex)\n    {\n        vector<int> line = {1};\n        \n        while(rowIndex--)\n        {\n            vector<int> new_line;\n            new_line.reserve(line.size()+1);\n            \n            new_line.emplace_back(1);\n            if(line.size()!=1)\n            {\n                for(int i = 0; i <line.size()-1; ++i)\n                    new_line.emplace_back(line[i]+line[i+1]);\n            }\n            new_line.emplace_back(1);\n            \n            line = std::move(new_line);\n        }\n        \n        return line;\n        \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "pascals-triangle-ii",
                        "submissions": {
                            "cpp": "379805369"
                        }
                    }
                },
                {
                    "name": "Path Sum",
                    "link": "https://leetcode.com/problems/path-sum",
                    "description": "<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given the below binary tree and <code>sum = 22</code>,</p>\r\n\r\n<pre>\r\n      <strong>5</strong>\r\n     <strong>/</strong> \\\r\n    <strong>4</strong>   8\r\n   <strong>/</strong>   / \\\r\n  <strong>11</strong>  13  4\r\n /  <strong>\\</strong>      \\\r\n7    <strong>2</strong>      1\r\n</pre>\r\n\r\n<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\n//using preorder traversal (passing info to the children)\n//each child\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum)\n    {\n        if (!root)\n            return false;\n\n        //if leaf return specific value\n        if(!root->left && !root->right)\n            //if it has value that fulfill the request\n            return root->val-sum == 0;\n        else //has more leafs\n            return hasPathSum(root->left, sum - root->val)\n                   || hasPathSum(root->right, sum - root->val);\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "path-sum",
                        "submissions": {
                            "cpp": "296476245"
                        }
                    }
                },
                {
                    "name": "Plus One",
                    "link": "https://leetcode.com/problems/plus-one",
                    "description": "<p>Given a <strong>non-empty</strong> array of digits&nbsp;representing a non-negative integer, increment&nbsp;one to the integer.</p>\n\n<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.</p>\n\n<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [1,2,3]\n<strong>Output:</strong> [1,2,4]\n<strong>Explanation:</strong> The array represents the integer 123.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [4,3,2,1]\n<strong>Output:</strong> [4,3,2,2]\n<strong>Explanation:</strong> The array represents the integer 4321.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [0]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits_original)\n    {\n        vector<int> digits = digits_original;\n        for(int i = digits.size()-1; i > -1 ; --i)\n        {\n            if(digits[i] != 9)digits[i]++;\n            else\n            {\n                digits[i] = 0;\n                if (i == 0)\n                {\n                    digits.insert(digits.begin(), 1);\n                }\n\n                continue;\n            }\n            break;\n        }\n        \n        return digits;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "plus-one",
                        "submissions": {
                            "cpp": "301710697"
                        }
                    }
                },
                {
                    "name": "Power of Four",
                    "link": "https://leetcode.com/problems/power-of-four",
                    "description": "<p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">16</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">5</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span></pre>\r\n</div>\r\n\r\n<p><b>Follow up</b>: Could you solve it without loops/recursion?</p>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <stdint.h>\n\nclass Solution\n{\npublic:\n    bool isPowerOfFour(unsigned num) \n    {\n      return (__builtin_popcount(num) == 1) && (num & 0b01010101010101010101010101010101);\n        // return num > 0 && (num & (num - 1)) == 0 && num & 0x55555555;\n//         if (num == 1) // case for power of 0\n//             return true;\n\n//         for (uint32_t i = 1; (i <<= 2);)\n//             if (i == num)\n//                 return true;\n//         return false;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "power-of-four",
                        "submissions": {
                            "cpp": "376408972"
                        }
                    }
                },
                {
                    "name": "Power of Two",
                    "link": "https://leetcode.com/problems/power-of-two",
                    "description": "<p>Given an integer <code>n</code>, write a function to determine if it is a power of two.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>0</sup> = 1\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 16\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>4</sup> = 16\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    bool isPowerOfTwo(int n)\n    {\n              return (__builtin_popcount(n) == 1) && (n & 0x7FFFFFFF);\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "power-of-two",
                        "submissions": {
                            "cpp": "405256850"
                        }
                    }
                },
                {
                    "name": "Remove Duplicates from Sorted Array",
                    "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array",
                    "description": "<p>Given a sorted array <em>nums</em>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> such that each element appears only <em>once</em> and returns the new length.</p>\n\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre>\nGiven <em>nums</em> = <strong>[1,1,2]</strong>,\n\nYour function should return length = <strong><code>2</code></strong>, with the first two elements of <em><code>nums</code></em> being <strong><code>1</code></strong> and <strong><code>2</code></strong> respectively.\n\nIt doesn&#39;t matter what you leave beyond the returned length.</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\nGiven <em>nums</em> = <strong>[0,0,1,1,1,2,2,3,3,4]</strong>,\n\nYour function should return length = <strong><code>5</code></strong>, with the first five elements of <em><code>nums</code></em> being modified to&nbsp;<strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, and&nbsp;<strong><code>4</code></strong> respectively.\n\nIt doesn&#39;t matter what values are set beyond&nbsp;the returned length.\n</pre>\n\n<p><strong>Clarification:</strong></p>\n\n<p>Confused why the returned value is an integer but your answer is an array?</p>\n\n<p>Note that the input array is passed in by <strong>reference</strong>, which means a modification to the input array will be known to the caller as well.</p>\n\n<p>Internally you can think of this:</p>\n\n<pre>\n// <strong>nums</strong> is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n\n// any modification to <strong>nums</strong> in your function would be known by the caller.\n// using the length returned by your function, it prints the first <strong>len</strong> elements.\nfor (int i = 0; i &lt; len; i++) {\n&nbsp; &nbsp; print(nums[i]);\n}</pre>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <algorithm>\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums)\n    {\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end() );\n        /*\n        for (auto prev_value = nums.begin(), i = prev_value+1;\n            i < nums.end();)\n        {\n            if(*i == *prev_value)\n                nums.erase(i);\n            else\n            {\n                prev_value = i;\n                i++;\n            }\n        }\n        */\n        return nums.size();\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "remove-duplicates-from-sorted-array",
                        "submissions": {
                            "cpp": "348041988"
                        }
                    }
                },
                {
                    "name": "Remove Element",
                    "link": "https://leetcode.com/problems/remove-element",
                    "description": "<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> and return the new length.</p>\r\n\r\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\r\n\r\n<p>The order of elements can be changed. It doesn&#39;t matter what you leave beyond the new length.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\nGiven <em>nums</em> = <strong>[3,2,2,3]</strong>, <em>val</em> = <strong>3</strong>,\r\n\r\nYour function should return length = <strong>2</strong>, with the first two elements of <em>nums</em> being <strong>2</strong>.\r\n\r\nIt doesn&#39;t matter what you leave beyond the returned length.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\nGiven <em>nums</em> = <strong>[0,1,2,2,3,0,4,2]</strong>, <em>val</em> = <strong>2</strong>,\r\n\r\nYour function should return length = <strong><code>5</code></strong>, with the first five elements of <em><code>nums</code></em> containing&nbsp;<strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>3</code></strong>, <strong><code>0</code></strong>, and&nbsp;<strong>4</strong>.\r\n\r\nNote that the order of those five elements can be arbitrary.\r\n\r\nIt doesn&#39;t matter what values are set beyond&nbsp;the returned length.</pre>\r\n\r\n<p><strong>Clarification:</strong></p>\r\n\r\n<p>Confused why the returned value is an integer but your answer is an array?</p>\r\n\r\n<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>\r\n\r\n<p>Internally you can think of this:</p>\r\n\r\n<pre>\r\n// <strong>nums</strong> is passed in by reference. (i.e., without making a copy)\r\nint len = removeElement(nums, val);\r\n\r\n// any modification to <strong>nums</strong> in your function would be known by the caller.\r\n// using the length returned by your function, it prints the first <strong>len</strong> elements.\r\nfor (int i = 0; i &lt; len; i++) {\r\n&nbsp; &nbsp; print(nums[i]);\r\n}</pre>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    int removeElement(vector<int>& nums, int val)\n    {\n        size_t len_without_val = nums.size();\n        for(int i = 0; i < len_without_val; )\n            if(nums[i] == val)\n            {\n                std:swap(nums[i], nums[len_without_val-1]);\n                len_without_val--;\n            }\n            else\n                ++i;\n        \n        return len_without_val;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "remove-element",
                        "submissions": {
                            "cpp": "399686418"
                        }
                    }
                },
                {
                    "name": "Replace Elements with Greatest Element on Right Side",
                    "link": "https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side",
                    "description": "<p>Given an array <code>arr</code>,&nbsp;replace every element in that array with the greatest element among the elements to its&nbsp;right, and replace the last element with <code>-1</code>.</p>\r\n\r\n<p>After doing so, return the array.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n<pre><strong>Input:</strong> arr = [17,18,5,4,6,1]\r\n<strong>Output:</strong> [18,6,6,6,1,-1]\r\n</pre>\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>\r\n\t<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    vector<int> replaceElements(vector<int> arr)\n    {\n        int right_max = *rbegin(arr);\n        *rbegin(arr) = -1;\n        \n        for(auto iter = ++rbegin(arr); iter < rend(arr); ++iter)\n        {\n            int old_value = *iter;\n            *iter = right_max;\n            right_max = std::max(old_value, right_max);\n        }\n        \n        return arr;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "replace-elements-with-greatest-element-on-right-side",
                        "submissions": {
                            "cpp": "399768941"
                        }
                    }
                },
                {
                    "name": "Reverse Bits",
                    "link": "https://leetcode.com/problems/reverse-bits",
                    "description": "<p>Reverse bits of a given 32 bits unsigned integer.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> 00000010100101000001111010011100\n<strong>Output:</strong> 00111001011110000010100101000000\n<strong>Explanation: </strong>The input binary string <b>00000010100101000001111010011100</b> represents the unsigned integer 43261596, so return 964176192 which its binary representation is <b>00111001011110000010100101000000</b>.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> 11111111111111111111111111111101\n<strong>Output:</strong> 10111111111111111111111111111111\n<strong>Explanation: </strong>The input binary string <strong>11111111111111111111111111111101</strong> represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is <strong>10111111111111111111111111111111</strong>.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.</li>\n\t<li>In Java,&nbsp;the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">2&#39;s complement notation</a>. Therefore, in <strong>Example 2</strong>&nbsp;above the input represents the signed integer <code>-3</code>&nbsp;and the output represents the signed integer <code>-1073741825</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>Follow up</b>:</p>\n\n<p>If this function is called many times, how would you optimize it?</p>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The input must be a <strong>binary string</strong> of <code>length = 32</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\n    void swap_bits(uint32_t &n, int i, int k)\n    {\n        bool i_value = n & (1 << i),\n             k_value = n & (1 << k);\n        \n        n = (n & ~(1<<k)) | (i_value << k);\n        n = (n & ~(1<<i)) | (k_value << i);\n    }\npublic:\n    uint32_t reverseBits(uint32_t n)\n    {\n        for(int i = 0; i< 16 ; ++i)\n            swap_bits(n, i, 31-i);\n        return n;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "reverse-bits",
                        "submissions": {
                            "cpp": "379585659"
                        }
                    }
                },
                {
                    "name": "Reverse Integer",
                    "link": "https://leetcode.com/problems/reverse-integer",
                    "description": "<p>Given a 32-bit signed integer, reverse digits of an integer.</p>\n\n<p><strong>Note:</strong><br />\nAssume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> x = 123\n<strong>Output:</strong> 321\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> x = -123\n<strong>Output:</strong> -321\n</pre><p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> x = 120\n<strong>Output:</strong> 21\n</pre><p><strong>Example 4:</strong></p>\n<pre><strong>Input:</strong> x = 0\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    int reverse(int x)\n    {\n        bool is_neg = x < 0;\n        std::string num = std::to_string(x);\n        std::reverse(num.begin()+is_neg, num.end());\n\n        long res = std::atol(num.c_str());\n        return res > numeric_limits<int>::max() || res < numeric_limits<int>::min() ? \n               0  : res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "reverse-integer",
                        "submissions": {
                            "cpp": "378507474"
                        }
                    }
                },
                {
                    "name": "Reverse String",
                    "link": "https://leetcode.com/problems/reverse-string",
                    "description": "<p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p>\r\n\r\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array&nbsp;<a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\r\n\r\n<p>You may assume all the characters consist of <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\" target=\"_blank\">printable ascii characters</a>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span>\r\n</pre>\r\n</div>\r\n</div>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    void reverseString(vector<char>& s)\n    {\n        for(int i = 0; i< s.size()/2; ++i)\n        {\n            char tmp = s[i];\n            s[i] = s[s.size()-1-i];\n            s[s.size()-1-i] = tmp;\n        }\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "reverse-string",
                        "submissions": {
                            "cpp": "349095215"
                        }
                    }
                },
                {
                    "name": "Roman to Integer",
                    "link": "https://leetcode.com/problems/roman-to-integer",
                    "description": "<p>Roman numerals are represented by seven different symbols:&nbsp;<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\r\n\r\n<pre>\r\n<strong>Symbol</strong>       <strong>Value</strong>\r\nI             1\r\nV             5\r\nX             10\r\nL             50\r\nC             100\r\nD             500\r\nM             1000</pre>\r\n\r\n<p>For example,&nbsp;two is written as <code>II</code>&nbsp;in Roman numeral, just two one&#39;s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>\r\n\r\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\r\n\r\n<ul>\r\n\t<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.&nbsp;</li>\r\n\t<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.&nbsp;</li>\r\n\t<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\r\n</ul>\r\n\r\n<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;III&quot;\r\n<strong>Output:</strong> 3</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;IV&quot;\r\n<strong>Output:</strong> 4</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;IX&quot;\r\n<strong>Output:</strong> 9</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;LVIII&quot;\r\n<strong>Output:</strong> 58\r\n<strong>Explanation:</strong> L = 50, V= 5, III = 3.\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;&quot;MCMXCIV&quot;\r\n<strong>Output:</strong> 1994\r\n<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.</pre>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <map>\n\nclass Solution\n{\n    map<char,int> rtoi =\n    {\n        {'I',1},\n        {'V',5},\n        {'X',10},\n        {'L',50},\n        {'C',100},\n        {'D',500},\n        {'M',1000},\n    };\npublic:\n    int romanToInt(string s)\n    {\n        unsigned res = 0;\n        for(size_t i = 0; i < s.size(); ++i)\n        {\n            if(i != s.size()-1)\n            {\n                if(s[i] == 'I' && (s[i+1] == 'V' || s[i+1] == 'X') ||\n                   s[i] == 'X' && (s[i+1] == 'L' || s[i+1] == 'C') ||\n                   s[i] == 'C' && (s[i+1] == 'D' || s[i+1] == 'M') )\n                {\n                    res+=rtoi[s[i+1]] - rtoi[s[i]];\n                    ++i; //we processed 2 symbols\n                    continue;\n                }\n            }\n                res+=rtoi[s[i]];\n            \n        }\n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "roman-to-integer",
                        "submissions": {
                            "cpp": "356520255"
                        }
                    }
                },
                {
                    "name": "Running Sum of 1d Array",
                    "link": "https://leetcode.com/problems/running-sum-of-1d-array",
                    "description": "<p>Given an array <code>nums</code>. We define a running sum of an array as&nbsp;<code>runningSum[i] = sum(nums[0]&hellip;nums[i])</code>.</p>\r\n\r\n<p>Return the running sum of <code>nums</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4]\r\n<strong>Output:</strong> [1,3,6,10]\r\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,1,1,1]\r\n<strong>Output:</strong> [1,2,3,4,5]\r\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [3,1,2,10,1]\r\n<strong>Output:</strong> [3,4,6,16,17]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\r\n\t<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <numeric>\n\nclass Solution\n{\npublic:\n    vector<int> runningSum(vector<int>& nums)\n    {\n        vector<int> res;\n//         res.reserve(nums.size());    \n//         std::accumulate(nums.begin(), nums.end(), 0, [&res](int &a, int &b)\n//                         {\n//                             const int sum = a+b;\n//                             res.emplace_back(sum);\n//                             return sum;\n//                         });\n        std::partial_sum(nums.begin(), nums.end(), std::back_inserter(res));\n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "running-sum-of-1d-array",
                        "submissions": {
                            "cpp": "380304122"
                        }
                    }
                },
                {
                    "name": "Shuffle the Array",
                    "link": "https://leetcode.com/problems/shuffle-the-array",
                    "description": "<p>Given the array <code>nums</code> consisting of <code>2n</code> elements in the form <code>[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>,y<sub>1</sub>,y<sub>2</sub>,...,y<sub>n</sub>]</code>.</p>\r\n\r\n<p><em>Return the array in the form</em> <code>[x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>,...,x<sub>n</sub>,y<sub>n</sub>]</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2,5,1,3,4,7], n = 3\r\n<strong>Output:</strong> [2,3,5,4,1,7] \r\n<strong>Explanation:</strong> Since x<sub>1</sub>=2, x<sub>2</sub>=5, x<sub>3</sub>=1, y<sub>1</sub>=3, y<sub>2</sub>=4, y<sub>3</sub>=7 then the answer is [2,3,5,4,1,7].\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4,4,3,2,1], n = 4\r\n<strong>Output:</strong> [1,4,2,3,3,2,4,1]\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,2,2], n = 2\r\n<strong>Output:</strong> [1,2,1,2]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\r\n\t<li><code>nums.length == 2n</code></li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    vector<int> shuffle(vector<int>& nums, const int n)\n    {\n        vector<int> res(nums.size());\n        auto start = nums.begin(),\n             middle = std::next(start,n);\n        \n        for (int i = 0; i < 2*n; i+=2)\n        {\n            res[i] = *start++;\n            res[i+1] = *middle++;\n        }\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "shuffle-the-array",
                        "submissions": {
                            "cpp": "380342304"
                        }
                    }
                },
                {
                    "name": "Single Number",
                    "link": "https://leetcode.com/problems/single-number",
                    "description": "<p>Given a <strong>non-empty</strong>&nbsp;array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>\n\n<p><strong>Follow up:</strong>&nbsp;Could you implement a solution with a linear runtime complexity and without using extra memory?</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,1]\n<strong>Output:</strong> 1\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,1,2,1,2]\n<strong>Output:</strong> 4\n</pre><p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li>Each element in the array appears twice except for one element which appears only once.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums)\n    {\n        for(int i=0; i < nums.size(); ++i)\n        {\n            for(int j=0; ; ++j)\n                if(nums[i] == nums[j] && i != j)\n                    break;\n                else if (j == nums.size()-1)\n                    return nums[i]; \n        }\n\n        return 0;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "single-number",
                        "submissions": {
                            "cpp": "348426014"
                        }
                    }
                },
                {
                    "name": "Sort Array By Parity",
                    "link": "https://leetcode.com/problems/sort-array-by-parity",
                    "description": "<p>Given an array <code>A</code> of non-negative integers, return an array consisting of all the even elements of <code>A</code>, followed by all the odd elements of <code>A</code>.</p>\r\n\r\n<p>You may return any answer array that satisfies this condition.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[3,1,2,4]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[2,4,3,1]</span>\r\nThe outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 5000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 5000</code></li>\r\n</ol>\r\n</div>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    vector<int> sortArrayByParity(vector<int>& A)\n    {\n        if(A.empty())\n            return A;\n        \n        auto iter0 = begin(A),\n             iter1 = --end(A);\n        \n        //O(N) two-pointers in-place solution\n        while(iter0 < iter1)\n        {\n            if(*iter0 % 2 == 1 && *iter1 % 2 == 0)\n                std::swap(*iter0, *iter1);\n            if(*iter0 % 2 == 0)\n                ++iter0;\n            if(*iter1 % 2 == 1)\n                --iter1;\n        }\n        \n        return A;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "sort-array-by-parity",
                        "submissions": {
                            "cpp": "400085372"
                        }
                    }
                },
                {
                    "name": "Squares of a Sorted Array",
                    "link": "https://leetcode.com/problems/squares-of-a-sorted-array",
                    "description": "<p>Given an array of integers <code>A</code>&nbsp;sorted in non-decreasing order,&nbsp;return an array of the squares of each number,&nbsp;also in sorted non-decreasing order.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[-4,-1,0,3,10]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[0,1,9,16,100]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[-7,-3,2,3,11]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[4,9,9,49,121]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong><span>Note:</span></strong></p>\r\n\r\n<ol>\r\n\t<li><code><span>1 &lt;= A.length &lt;= 10000</span></code></li>\r\n\t<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>\r\n\t<li><code>A</code>&nbsp;is sorted in non-decreasing order.</li>\r\n</ol>\r\n</div>\r\n</div>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    vector<int> sortedSquares(vector<int>& A)\n    {        \n        multiset<int> sorted_squares;\n        for(int num : A)\n            sorted_squares.insert(num*num);\n        \n        return vector<int>(begin(sorted_squares), end(sorted_squares));\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "squares-of-a-sorted-array",
                        "submissions": {
                            "cpp": "400085586"
                        }
                    }
                },
                {
                    "name": "Sum of Left Leaves",
                    "link": "https://leetcode.com/problems/sum-of-left-leaves",
                    "description": "<p>Find the sum of all left leaves in a given binary tree.</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\nThere are two left leaves in the binary tree, with values <b>9</b> and <b>15</b> respectively. Return <b>24</b>.\r\n</pre>\r\n</p>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution\n{ \n    enum Leaf{R, L};\npublic:\n    int sumOfLeftLeaves(TreeNode* node, Leaf pos = R)\n    {\n        if(!node)\n            return 0;\n        \n        if(pos == L && !node->right && !node->left)\n            return node->val;\n        \n        return sumOfLeftLeaves(node->right, R) + sumOfLeftLeaves(node->left, L);\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "sum-of-left-leaves",
                        "submissions": {
                            "cpp": "385646749"
                        }
                    }
                },
                {
                    "name": "Sum of Root To Leaf Binary Numbers",
                    "link": "https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers",
                    "description": "<p>You are given the <code>root</code> of a binary tree where each node has a value <code>0</code>&nbsp;or <code>1</code>.&nbsp; Each root-to-leaf path represents a binary number starting with the most significant bit.&nbsp; For example, if the path is <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>, then this could represent <code>01101</code> in binary, which is <code>13</code>.</p>\n\n<p>For all leaves in the tree, consider the numbers represented by the path&nbsp;from the root to that leaf.</p>\n\n<p>Return <em>the sum of these numbers</em>. The answer is <strong>guaranteed</strong> to fit in a <strong>32-bits</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png\" style=\"width: 450px; height: 296px;\" />\n<pre>\n<strong>Input:</strong> root = [1,0,1,0,1,0,1]\n<strong>Output:</strong> 22\n<strong>Explanation: </strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0]\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,1]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>Node.val</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution\n{\n    //list of binary represented\n    static list<list<int>> getAllNumbers(TreeNode* root)\n    {\n        if(!root)\n            return {};\n        //if leaf\n        if(!root->left && !root->right)\n            return list<list<int>>{{root->val}};\n        \n        list<list<int>> res;\n        auto process_leaf = [&](TreeNode* leaf)\n        {\n            if(leaf)\n            for(auto num : getAllNumbers(leaf))\n            {\n                num.push_front(root->val);\n                res.push_back(num);\n            }\n        };\n        \n        process_leaf(root->left);\n        process_leaf(root->right);\n        \n        return res;\n    }\n\npublic:\n    int sumRootToLeaf(TreeNode* root)\n    {\n        int res = 0;\n        for(auto num : getAllNumbers(root))\n        {\n            string binary_string;\n            for(int bit : num)\n                binary_string.push_back(to_string(bit)[0]);\n            res += std::stoi(binary_string, nullptr, 2);\n        }\n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "sum-of-root-to-leaf-binary-numbers",
                        "submissions": {
                            "cpp": "392946463"
                        }
                    }
                },
                {
                    "name": "Symmetric Tree",
                    "link": "https://leetcode.com/problems/symmetric-tree",
                    "description": "<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>\n\n<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>\n\n<pre>\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</pre>\n\n<p>&nbsp;</p>\n\n<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>\n\n<pre>\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>Follow up:</b> Solve it both recursively and iteratively.</p>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\n#include <utility>\nclass Solution\n{\npublic:\n    bool isSymmetric(TreeNode* root)\n    {\n        if(!root)\n            return true;\n        if( !!root->left != !!root->right)\n            return false;\n        if(!root->left)\n            return true;\n\n        //idea use level-traversal \n        //to check that left and right side has symetric leafs\n        \n        //we will check level by level\n        //each level will have 2*n elements\n        list<TreeNode*> level{root->left, root->right};\n        \n        while(!level.empty())\n        {\n            list<TreeNode*> next_level_left;\n            list<TreeNode*> next_level_right;\n            \n            for(TreeNode *left_el=level.front(), *right_el =level.back();\n                !level.empty();\n                left_el=level.front(), right_el = level.back())\n            {\n                //check for symmetric form\n                if( !!left_el->left == !!right_el->right && !!left_el->right == !!right_el->left\n                //check for same content\n                   && left_el->val == right_el->val )\n                {\n                    if(left_el->left)\n                    {\n                        next_level_left.emplace_back(left_el->left);\n                        next_level_right.emplace_back(right_el->right);\n                    }\n                    if(left_el->right)\n                    {\n                        next_level_left.emplace_back(left_el->right);\n                        next_level_right.emplace_back(right_el->left);\n                    }\n                    \n                    level.pop_front();\n                    level.pop_back();\n                }\n                else\n                    return false;\n            }\n            \n            reverse(next_level_right.begin(), next_level_right.end());\n            level = std::move(next_level_left);\n            level.insert(level.end(),\n                         std::make_move_iterator(next_level_right.begin()),\n                         std::make_move_iterator(next_level_right.end()));\n             \n            \n        }\n        \n        return true;\n        \n        \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "symmetric-tree",
                        "submissions": {
                            "cpp": "296453595"
                        }
                    }
                },
                {
                    "name": "Tenth Line",
                    "link": "https://leetcode.com/problems/tenth-line",
                    "description": "<p>Given a text file&nbsp;<code>file.txt</code>, print&nbsp;just the 10th line of the&nbsp;file.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Assume that <code>file.txt</code> has the following content:</p>\r\n\r\n<pre>\r\nLine 1\r\nLine 2\r\nLine 3\r\nLine 4\r\nLine 5\r\nLine 6\r\nLine 7\r\nLine 8\r\nLine 9\r\nLine 10\r\n</pre>\r\n\r\n<p>Your script should output the tenth line, which is:</p>\r\n\r\n<pre>\r\nLine 10\r\n</pre>\r\n\r\n<div class=\"spoilers\"><b>Note:</b><br />\r\n1. If the file contains less than 10 lines, what should you output?<br />\r\n2. There&#39;s at least three different solutions. Try to explore all possibilities.</div>\r\n",
                    "solutions": {
                        "bash": [
                            {
                                "language": "bash",
                                "code": "# Read from the file file.txt and output the tenth line to stdout.\nif [ $(wc -l file.txt | cut -f1 -d' ') -gt 9 ]\nthen\n    cat file.txt | head -n 10 | tail -n 1\nfi"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "tenth-line",
                        "submissions": {
                            "bash": "378806493"
                        }
                    }
                },
                {
                    "name": "Third Maximum Number",
                    "link": "https://leetcode.com/problems/third-maximum-number",
                    "description": "<p>Given a <b>non-empty</b> array of integers, return the <b>third</b> maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [3, 2, 1]\r\n\r\n<b>Output:</b> 1\r\n\r\n<b>Explanation:</b> The third maximum is 1.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [1, 2]\r\n\r\n<b>Output:</b> 2\r\n\r\n<b>Explanation:</b> The third maximum does not exist, so the maximum (2) is returned instead.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 3:</b><br />\r\n<pre>\r\n<b>Input:</b> [2, 2, 3, 1]\r\n\r\n<b>Output:</b> 1\r\n\r\n<b>Explanation:</b> Note that the third maximum here means the third maximum distinct number.\r\nBoth numbers with value 2 are both considered as second maximum.\r\n</pre>\r\n</p>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    int thirdMax(vector<int> nums)\n    {\n        std::sort(nums.begin(), nums.end());\n        nums.erase(std::unique(nums.begin(), nums.end()), nums.end());\n\n        const size_t uniq_size = nums.size();\n        if(uniq_size < 3)\n            return nums[uniq_size-1];\n        else\n        {\n            return nums[uniq_size-3];\n        }\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "third-maximum-number",
                        "submissions": {
                            "cpp": "400100342"
                        }
                    }
                },
                {
                    "name": "Transpose Matrix",
                    "link": "https://leetcode.com/problems/transpose-matrix",
                    "description": "<p>Given a&nbsp;matrix <code>A</code>, return the transpose of <code>A</code>.</p>\r\n\r\n<p>The transpose of a matrix is the matrix flipped over it&#39;s main diagonal, switching the row and column indices of the matrix.</p>\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_transpose.png\" width=\"700\"/>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[1,2,3],[4,5,6],[7,8,9]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[[1,4,7],[2,5,8],[3,6,9]]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[[1,2,3],[4,5,6]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[[1,4],[2,5],[3,6]]</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><span><strong>Note:</strong></span></p>\r\n\r\n<ol>\r\n\t<li><code><span>1 &lt;= A.length&nbsp;&lt;= 1000</span></code></li>\r\n\t<li><code><span>1 &lt;= A[0].length&nbsp;&lt;= 1000</span></code></li>\r\n</ol>\r\n</div>\r\n</div>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& A)\n    {\n        const size_t  new_length = A.size(),\n                      new_height = A[0].size();\n        vector<vector<int>> res;\n        res.resize(new_height);\n        for(auto &v : res)\n            v.resize(new_length);\n        \n        for(size_t i = 0; i < new_length; ++i)\n            for(size_t j = 0; j < new_height; ++j)\n                res[j][i] = A[i][j];\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "transpose-matrix",
                        "submissions": {
                            "cpp": "380302377"
                        }
                    }
                },
                {
                    "name": "Two Sum",
                    "link": "https://leetcode.com/problems/two-sum",
                    "description": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Output:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <algorithm>\n\nclass Solution\n{\npublic:\n    vector<int> twoSum(vector<int> nums, int target) \n    {\n        std::remove_if(nums.begin(), nums.end(), [target](int i){ return i > target;});\n        for(auto el = nums.begin(); el != nums.end(); el++)\n            for(auto el2 = el; ++el2 != nums.end();)\n                if(*el + *el2 == target)\n                    return {(int)(el-nums.begin()),(int)(el2-nums.begin())};\n        return {};\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "two-sum",
                        "submissions": {
                            "cpp": "348882290"
                        }
                    }
                },
                {
                    "name": "Valid Anagram",
                    "link": "https://leetcode.com/problems/valid-anagram",
                    "description": "<p>Given two strings <em>s</em> and <em>t&nbsp;</em>, write a function to determine if <em>t</em> is an anagram of <em>s</em>.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <em>s</em> = &quot;anagram&quot;, <em>t</em> = &quot;nagaram&quot;\r\n<b>Output:</b> true\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <em>s</em> = &quot;rat&quot;, <em>t</em> = &quot;car&quot;\r\n<b>Output: </b>false\r\n</pre>\r\n\r\n<p><strong>Note:</strong><br />\r\nYou may assume the string contains only lowercase alphabets.</p>\r\n\r\n<p><strong>Follow up:</strong><br />\r\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case?</p>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <algorithm>\nclass Solution\n{\npublic:\n    bool isAnagram(string s, string t)\n    {\n        std::sort(s.begin(), s.end());\n        std::sort(t.begin(), t.end());\n        return s == t;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "valid-anagram",
                        "submissions": {
                            "cpp": "303804795"
                        }
                    }
                },
                {
                    "name": "Valid Mountain Array",
                    "link": "https://leetcode.com/problems/valid-mountain-array",
                    "description": "<p>Given an array <code>A</code> of integers, return <code>true</code> if and only if it is a <em>valid mountain array</em>.</p>\r\n\r\n<p>Recall that A is a mountain array if and only if:</p>\r\n\r\n<ul>\r\n\t<li><code>A.length &gt;= 3</code></li>\r\n\t<li>There exists some <code>i</code> with&nbsp;<code>0 &lt; i&nbsp;&lt; A.length - 1</code>&nbsp;such that:\r\n\t<ul>\r\n\t\t<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] </code></li>\r\n\t\t<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>\r\n\t</ul>\r\n\t</li>\r\n</ul>\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png\" width=\"500\" />\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[2,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">false</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[3,5,5]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">false</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[0,3,2,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">true</span></pre>\r\n</div>\r\n</div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>0 &lt;= A.length &lt;= 10000</code></li>\r\n\t<li><code>0 &lt;= A[i] &lt;= 10000&nbsp;</code></li>\r\n</ol>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n</div>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    //O(n) solution\n    bool validMountainArray(vector<int>& A)\n    {\n        //empty is no mountain\n        if(A.empty())\n            return false;\n\n        bool going_up = true;\n        for(auto iter = ++begin(A); iter < end(A); ++iter)\n        {\n            //no flat\n            if(*iter == *prev(iter))\n               return false;\n            \n            //go up\n            if(*prev(iter) < *iter)\n            {\n                //if we went up after we went down\n                if(!going_up)\n                    return false;\n            }\n            //go down\n            else if(*prev(iter) > *iter )\n            {\n                //if we going down from the start\n                if(prev(iter) == begin(A))\n                    return false;\n                //started to gow down\n                if(going_up)\n                    going_up = false;\n            }           \n        }\n        \n        //if we were going up all the time, return false\n        return !going_up;\n\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "valid-mountain-array",
                        "submissions": {
                            "cpp": "399765332"
                        }
                    }
                },
                {
                    "name": "Valid Parentheses",
                    "link": "https://leetcode.com/problems/valid-parentheses",
                    "description": "<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n\n<p>An input string is valid if:</p>\n\n<ol>\n\t<li>Open brackets must be closed by the same type of brackets.</li>\n\t<li>Open brackets must be closed in the correct order.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()[]{}&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(]&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;([)]&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;{[]}&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\n    std::map<char,char> p_pairs\n    {\n        {'}','{'},\n        {')','('},\n        {']','['},\n        {'{',' '},\n        {'(',' '},\n        {'[',' '},\n    };\n\npublic:\n    bool isValid(string s)\n    {\n        std::stack<char> parenthesis;\n        for(char ch : s)\n        {\n            \n            if(p_pairs[ch] == ' ')\n                parenthesis.push(ch);\n            else if(parenthesis.size() && p_pairs[ch] == parenthesis.top())\n                parenthesis.pop();\n            else \n                return false;\n        }\n        \n        return parenthesis.empty();\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "valid-parentheses",
                        "submissions": {
                            "cpp": "401005957"
                        }
                    }
                },
                {
                    "name": "Word Pattern",
                    "link": "https://leetcode.com/problems/word-pattern",
                    "description": "<p>Given a <code>pattern</code> and a string <code>s</code>, find if <code>s</code>&nbsp;follows the same pattern.</p>\n\n<p>Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> word in <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;abba&quot;, s = &quot;dog dog dog dog&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 300</code></li>\n\t<li><code>pattern</code> contains only lower-case English letters.</li>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code> contains only lower-case English letters and spaces <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> <strong>does not contain</strong> any leading or trailing spaces.</li>\n\t<li>All the words in <code>s</code> are separated by a <strong>single space</strong>.</li>\n</ul>\n",
                    "solutions": {
                        "python": [
                            {
                                "language": "python",
                                "code": "class Solution:\n    def wordPattern(self, pattern: str, words: str) -> bool:\n        d = dict()\n        if len(pattern) != len(words.split()):\n            return False\n        \n        for a, b in zip(pattern, words.split()):\n            if a in d.keys():\n                if d[a] != b:\n                    return False\n            elif b not in d.values():\n                d[a] = b\n            else:\n                return False\n                \n        return True\n        \n        "
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "word-pattern",
                        "submissions": {
                            "python": "392715817"
                        }
                    }
                },
                {
                    "name": "XOR Operation in an Array",
                    "link": "https://leetcode.com/problems/xor-operation-in-an-array",
                    "description": "<p>Given an integer <code>n</code> and an integer <code>start</code>.</p>\r\n\r\n<p>Define an array <code>nums</code> where <code>nums[i] = start + 2*i</code> (0-indexed) and <code>n == nums.length</code>.</p>\r\n\r\n<p>Return the bitwise&nbsp;XOR&nbsp;of all elements of <code>nums</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 5, start = 0\r\n<strong>Output:</strong> 8\r\n<strong>Explanation: </strong>Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\r\nWhere &quot;^&quot; corresponds to bitwise XOR operator.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 4, start = 3\r\n<strong>Output:</strong> 8\r\n<strong>Explanation: </strong>Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 1, start = 7\r\n<strong>Output:</strong> 7\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 10, start = 5\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\r\n\t<li><code>0 &lt;= start &lt;= 1000</code></li>\r\n\t<li><code>n == nums.length</code></li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    int xorOperation(int n, int start)\n    {\n        int res = start;\n        for(size_t i = 1 ; i < n; ++i)\n            res ^= start+2*i;\n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "xor-operation-in-an-array",
                        "submissions": {
                            "cpp": "380331905"
                        }
                    }
                }
            ]
        },
        {
            "name": "\ud83d\udc4a Medium",
            "tasks": [
                {
                    "name": "All Elements in Two Binary Search Trees",
                    "link": "https://leetcode.com/problems/all-elements-in-two-binary-search-trees",
                    "description": "<p>Given two binary search trees <code>root1</code> and <code>root2</code>.</p>\n\n<p>Return a list containing <em>all the integers</em> from <em>both trees</em> sorted in <strong>ascending</strong> order.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/q2-e1.png\" style=\"width: 457px; height: 207px;\" />\n<pre>\n<strong>Input:</strong> root1 = [2,1,4], root2 = [1,0,3]\n<strong>Output:</strong> [0,1,1,2,3,4]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root1 = [0,-10,10], root2 = [5,1,7,0,2]\n<strong>Output:</strong> [-10,0,0,1,2,5,7,10]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root1 = [], root2 = [5,1,7,0,2]\n<strong>Output:</strong> [0,1,2,5,7]\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> root1 = [0,-10,10], root2 = []\n<strong>Output:</strong> [-10,0,10]\n</pre>\n\n<p><strong>Example 5:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/q2-e5-.png\" style=\"width: 352px; height: 197px;\" />\n<pre>\n<strong>Input:</strong> root1 = [1,null,8], root2 = [8,1]\n<strong>Output:</strong> [1,1,8,8]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>Each tree has at most <code>5000</code> nodes.</li>\n\t<li>Each node&#39;s value is between <code>[-10^5, 10^5]</code>.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution\n{\n    void insert_node(TreeNode *&root, int val)\n    {\n        if(!root) \n            root = new TreeNode(val);\n        else if(val < root->val)\n        {\n            if(root->left)\n                insert_node(root->left, val);\n            else\n                root->left = new TreeNode(val);\n        }\n        else\n        {\n            if(root->right)\n                insert_node(root->right, val);\n            else\n                root->right = new TreeNode(val);\n        }\n    }\n    \n    void for_each_node(TreeNode *root, std::function<void(int)> func)\n    {\n        if(!root) return;\n        \n        for_each_node(root->left, func);\n        func(root->val);\n        for_each_node(root->right, func);  \n    }\n    \n\npublic:\n    vector<int> getAllElements(TreeNode *root1, TreeNode *root2)\n    {\n        for_each_node(root2, [&root1, this](int val){ this->insert_node(root1, val); } );\n        \n        vector<int> res;\n        for_each_node(root1, [&res](int val){ res.push_back(val); });\n        return res;\n        \n    }\n        \n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "all-elements-in-two-binary-search-trees",
                        "submissions": {
                            "cpp": "391792823"
                        }
                    }
                },
                {
                    "name": "Binary Tree Inorder Traversal",
                    "link": "https://leetcode.com/problems/binary-tree-inorder-traversal",
                    "description": "<p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 202px; height: 324px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,3,2]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p><strong>Example 4:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2]\n<strong>Output:</strong> [2,1]\n</pre>\n\n<p><strong>Example 5:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>Follow up:</strong></p>\n\n<p>Recursive solution is trivial, could you do it iteratively?</p>\n\n<p>&nbsp;</p>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode\n {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution\n{\npublic:\n    vector<int> inorderTraversal(TreeNode* root)\n    {\n        vector<int> res;\n        \n        if(!root)\n            return res;\n        if(root->left)\n        {\n            vector<int> &&tres = inorderTraversal(root->left);\n            res.insert(res.end(), tres.begin(), tres.end());\n        }\n        \n        res.emplace_back(root->val);\n        \n        if(root->right)\n        {\n            vector<int> &&tres = inorderTraversal(root->right);\n            res.insert(res.end(), tres.begin(), tres.end());\n        }\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "binary-tree-inorder-traversal",
                        "submissions": {
                            "cpp": "295877642"
                        }
                    }
                },
                {
                    "name": "Binary Tree Level Order Traversal",
                    "link": "https://leetcode.com/problems/binary-tree-level-order-traversal",
                    "description": "<p>Given a binary tree, return the <i>level order</i> traversal of its nodes' values. (ie, from left to right, level by level).</p>\r\n\r\n<p>\r\nFor example:<br />\r\nGiven binary tree <code>[3,9,20,null,null,15,7]</code>,<br />\r\n<pre>\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n</pre>\r\n</p>\r\n<p>\r\nreturn its level order traversal as:<br />\r\n<pre>\r\n[\r\n  [3],\r\n  [9,20],\r\n  [15,7]\r\n]\r\n</pre>\r\n</p>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\n#include <queue>\n#include <utility>\n\nclass Solution\n{\n    \npublic:\n    vector<vector<int>> levelOrder(TreeNode* root)\n    {\n        if(!root)\n            return {};\n        \n        vector<vector<int>> res{};\n        std::queue<TreeNode* >   q_to_process;\n        q_to_process.push(root);\n        \n        do\n        {\n            //capture of this level values\n            vector<int> level;\n            //list of next level node to process on the next iteration\n            std::queue<TreeNode*> q_next;\n            \n            for(TreeNode* node = q_to_process.front() ; !q_to_process.empty(); node = q_to_process.front())\n            {\n                q_to_process.pop();\n\n                level.push_back(node->val);\n                if(node->left)\n                    q_next.push(node->left);\n                if(node->right)\n                    q_next.push(node->right);\n            }\n            \n            res.push_back(std::move(level));\n            q_to_process = std::move(q_next);\n            \n        }while(!q_to_process.empty());\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "binary-tree-level-order-traversal",
                        "submissions": {
                            "cpp": "296177178"
                        }
                    }
                },
                {
                    "name": "Binary Tree Postorder Traversal",
                    "link": "https://leetcode.com/problems/binary-tree-postorder-traversal",
                    "description": "<p>Given the <code>root</code> of a&nbsp;binary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg\" style=\"width: 202px; height: 317px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [3,2,1]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p><strong>Example 4:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/pre3.jpg\" style=\"width: 202px; height: 197px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2]\n<strong>Output:</strong> [2,1]\n</pre>\n\n<p><strong>Example 5:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/pre2.jpg\" style=\"width: 202px; height: 197px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2]\n<strong>Output:</strong> [2,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>Follow up:</strong></p>\n\n<p>Recursive solution is trivial, could you do it iteratively?</p>\n\n<p>&nbsp;</p>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root)\n    {\n        vector<int> res;\n        \n        if(!root)\n            return res;\n        if(root->left)\n        {\n            vector<int> &&tres = postorderTraversal(root->left);\n            res.insert(res.end(), tres.begin(), tres.end());\n        }\n        \n        if(root->right)\n        {\n            vector<int> &&tres = postorderTraversal(root->right);\n            res.insert(res.end(), tres.begin(), tres.end());\n        }\n        \n        res.emplace_back(root->val);\n        \n\n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "binary-tree-postorder-traversal",
                        "submissions": {
                            "cpp": "295894604"
                        }
                    }
                },
                {
                    "name": "Binary Tree Preorder Traversal",
                    "link": "https://leetcode.com/problems/binary-tree-preorder-traversal",
                    "description": "<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 202px; height: 324px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p><strong>Example 4:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong>Example 5:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>Follow up:</strong></p>\n\n<p>Recursive solution is trivial, could you do it iteratively?</p>\n\n<p>&nbsp;</p>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode\n {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution\n{\npublic:\n    vector<int> preorderTraversal(TreeNode* root)\n    {\n        vector<int> res;\n        \n        if(root)\n            res.emplace_back(root->val);\n        else\n            return res;\n        if(root->left)\n        {\n            vector<int> &&lres = preorderTraversal(root->left);\n            res.insert(res.end(), lres.begin(), lres.end());\n        }\n        if(root->right)\n        {\n            vector<int> &&lres = preorderTraversal(root->right);\n            res.insert(res.end(), lres.begin(), lres.end());\n        }\n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "binary-tree-preorder-traversal",
                        "submissions": {
                            "cpp": "295876855"
                        }
                    }
                },
                {
                    "name": "Bulls and Cows",
                    "link": "https://leetcode.com/problems/bulls-and-cows",
                    "description": "<p>You are playing the <strong><a href=\"https://en.wikipedia.org/wiki/Bulls_and_Cows\" target=\"_blank\">Bulls and Cows</a></strong> game with your friend.</p>\n\n<p>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</p>\n\n<ul>\n\t<li>The number of &quot;bulls&quot;, which are digits in the guess that are in the correct position.</li>\n\t<li>The number of &quot;cows&quot;, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</li>\n</ul>\n\n<p>Given the secret number <code>secret</code> and your friend&#39;s guess <code>guess</code>, return <em>the hint for your friend&#39;s guess</em>.</p>\n\n<p>The hint should be formatted as <code>&quot;xAyB&quot;</code>, where <code>x</code> is the number of bulls and <code>y</code> is the number of cows. Note that both <code>secret</code> and <code>guess</code> may contain duplicate digits.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1807&quot;, guess = &quot;7810&quot;\n<strong>Output:</strong> &quot;1A3B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1807&quot;\n  |\n&quot;<u>7</u>8<u>10</u>&quot;</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1123&quot;, guess = &quot;0111&quot;\n<strong>Output:</strong> &quot;1A1B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1123&quot;        &quot;1123&quot;\n  |      or     |\n&quot;01<u>1</u>1&quot;        &quot;011<u>1</u>&quot;\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1&quot;, guess = &quot;0&quot;\n<strong>Output:</strong> &quot;0A0B&quot;\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1&quot;, guess = &quot;1&quot;\n<strong>Output:</strong> &quot;1A0B&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> and <code>guess</code> consist of digits only.</li>\n</ul>\n",
                    "solutions": {
                        "python": [
                            {
                                "language": "python",
                                "code": "class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        a,b = 0, 0\n        inplace_indexs=[]\n        for i, s, g in zip(range(len(secret)), secret, guess):\n            if g == s:\n                inplace_indexs.append(i)\n                a+=1\n                \n        secret_outplace=[el for i,el in enumerate(secret) if i not in inplace_indexs]\n        seen_outplace=[]\n        for i, s, g in zip(range(len(secret)), secret, guess):\n            if  i not in inplace_indexs and g in secret_outplace and seen_outplace.count(g) < secret_outplace.count(g):\n                seen_outplace.append(g)\n                b+=1\n        return f\"{a}A{b}B\"\n    \n        "
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "bulls-and-cows",
                        "submissions": {
                            "python": "394090296"
                        }
                    }
                },
                {
                    "name": "Car Pooling",
                    "link": "https://leetcode.com/problems/car-pooling",
                    "description": "<p>You are driving a vehicle that&nbsp;has <code>capacity</code> empty seats initially available for passengers.&nbsp; The vehicle <strong>only</strong> drives east (ie. it <strong>cannot</strong> turn around and drive west.)</p>\n\n<p>Given a list of <code>trips</code>, <code>trip[i] = [num_passengers, start_location, end_location]</code>&nbsp;contains information about the <code>i</code>-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off.&nbsp; The locations are given as the number of kilometers&nbsp;due east from your vehicle&#39;s initial location.</p>\n\n<p>Return <code>true</code> if and only if&nbsp;it is possible to pick up and drop off all passengers for all the given trips.&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input: </strong>trips = <span id=\"example-input-1-1\">[[2,1,5],[3,3,7]]</span>, capacity = <span id=\"example-input-1-2\">4</span>\n<strong>Output: </strong><span id=\"example-output-1\">false</span>\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input: </strong>trips = <span id=\"example-input-2-1\">[[2,1,5],[3,3,7]]</span>, capacity = <span id=\"example-input-2-2\">5</span>\n<strong>Output: </strong><span id=\"example-output-2\">true</span>\n</pre>\n\n<div>\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input: </strong>trips = <span id=\"example-input-3-1\">[[2,1,5],[3,5,7]]</span>, capacity = <span id=\"example-input-3-2\">3</span>\n<strong>Output: </strong><span id=\"example-output-3\">true</span>\n</pre>\n\n<div>\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input: </strong>trips = <span id=\"example-input-4-1\">[[3,2,7],[3,7,9],[8,3,9]]</span>, capacity = <span id=\"example-input-4-2\">11</span>\n<strong>Output: </strong><span id=\"example-output-4\">true</span>\n</pre>\n</div>\n</div>\n</div>\n\n<div>\n<div>\n<div>\n<div>&nbsp;</div>\n</div>\n</div>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ol>\n\t<li><code>trips.length &lt;= 1000</code></li>\n\t<li><code>trips[i].length == 3</code></li>\n\t<li><code>1 &lt;= trips[i][0] &lt;= 100</code></li>\n\t<li><code>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000</code></li>\n\t<li><code>1 &lt;=&nbsp;capacity &lt;= 100000</code></li>\n</ol>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\n    enum\n    {\n        NUM_PASS,\n        START,\n        END\n    };\n\npublic:\n    bool carPooling(vector<vector<int>> trips, int capacity)\n    {\n        //sort by starting point\n        std::sort(begin(trips), end(trips),\n                 [](auto a, auto b)\n                 {\n                     return a[START] < b[START];\n                 });\n        \n        \n        list<vector<int>*> bus;\n        size_t passenger_num = 0;\n        for(auto &trip : trips)\n        {\n            for(auto *&passenger : bus)\n            {\n                if(!passenger)\n                    continue;\n\n                //get off the bus unneeded passengers\n                if((*passenger)[END] <= trip[START])\n                {\n                    passenger_num -= (*passenger)[NUM_PASS];\n                    passenger = nullptr;\n                }\n            }\n            \n            if(passenger_num + trip[NUM_PASS] <= capacity)\n            {\n                bus.push_back(&trip);\n                passenger_num += trip[NUM_PASS];\n            }\n            else\n                return false;\n        }\n        \n        return true;   \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "car-pooling",
                        "submissions": {
                            "cpp": "398873183"
                        }
                    }
                },
                {
                    "name": "Combination Sum",
                    "link": "https://leetcode.com/problems/combination-sum",
                    "description": "<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of </em><code>candidates</code><em> where the chosen numbers sum to </em><code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>\n\n<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>\n\n<p>It is <strong>guaranteed</strong> that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,6,7], target = 7\n<strong>Output:</strong> [[2,2,3],[7]]\n<strong>Explanation:</strong>\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,5], target = 8\n<strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2], target = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [1], target = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [1], target = 2\n<strong>Output:</strong> [[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= candidates[i] &lt;= 200</code></li>\n\t<li>All elements of <code>candidates</code> are <strong>distinct</strong>.</li>\n\t<li><code>1 &lt;= target &lt;= 500</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\nprivate:\n    struct input\n    {\n        input(vector<int> a, int b) : allowed_nums(a), target(b) {}\n        bool operator<(input const &b) const\n        {\n            return target < b.target;\n        }\n        vector<int> allowed_nums;\n        int target;\n    };\n    \n    map<input, vector<vector<int>> > combinationSums;\n      \npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\n    {\n        //DP part\n        {\n            input a = {candidates, target};\n            auto DP_res = combinationSums.find(a);\n            if(DP_res != end(combinationSums))\n                return DP_res->second;\n        }\n        \n        set<vector<int>> res;\n        for(int candidate : candidates)\n        {\n            if(target < candidate)\n                continue;\n            else if(target == candidate)\n            {\n                res.insert({candidate});\n            }\n            else if(target > candidate)\n            {\n                vector<vector<int>> sub_res = combinationSum(candidates, target-candidate);\n                if(sub_res.empty())\n                    continue;\n                \n                //if we have valid sub_res:\n                for(auto &v : sub_res)\n                {\n                    v.push_back(candidate);\n                    std::sort(begin(v), end(v));\n                }\n\n                //add this to result\n                res.insert(begin(sub_res), end(sub_res));\n            }\n        }\n        \n        //DP memoization\n        input a = {candidates, target};\n        combinationSums.insert(pair<input, vector< vector <int> > >(a, {res.begin(), res.end()}));\n\n        return {res.begin(), res.end()};\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "combination-sum",
                        "submissions": {
                            "cpp": "403826208"
                        }
                    }
                },
                {
                    "name": "Combination Sum III",
                    "link": "https://leetcode.com/problems/combination-sum-iii",
                    "description": "<p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>\n\n<ul>\n\t<li>Only numbers <code>1</code> through <code>9</code> are used.</li>\n\t<li>Each number is used <strong>at most once</strong>.</li>\n</ul>\n\n<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 7\n<strong>Output:</strong> [[1,2,4]]\n<strong>Explanation:</strong>\n1 + 2 + 4 = 7\nThere are no other valid combinations.</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 9\n<strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]\n<strong>Explanation:</strong>\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 4, n = 1\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no valid combinations. [1,2,1] is not valid because 1 is used twice.\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 2\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no valid combinations.\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 9, n = 45\n<strong>Output:</strong> [[1,2,3,4,5,6,7,8,9]]\n<strong>Explanation:</strong>\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n\u200b\u200b\u200b\u200b\u200b\u200b\u200bThere are no other valid combinations.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\n    \n    //size_t pick_next_free_position(char &bitmask, current)\npublic:\n    vector<vector<int>> combinationSum3(int k, int n)\n    {\n        //input validation\n        if(k > n)\n            return {};\n        \n        vector<vector<int>> res;\n        set<vector<int>> res_set;\n        vector<int> holder(k, 1);\n        //to mark current selected numbers\n        \n        size_t iter_max = std::min(9, (n > 3 ? n-k+1 : n));\n\n        function<void(size_t, vector<int>)> increment_holder;\n        //add vector of num to ignore to ignore\n        increment_holder = [&](size_t pos, vector<int> to_ignore)\n        {\n            for(int i = 0; i <= iter_max; )\n            {\n                if(i == iter_max)\n                {\n                    holder[pos] = 1;\n                    break;\n                }\n\n                if(pos==k-1)\n                {\n                    const int sum = std::accumulate(holder.begin(), holder.end(),0);\n                    if(sum == n)\n                    {\n                        auto holder_copy = holder;\n                        std::sort(holder_copy.begin(), holder_copy.end());\n                        auto uq_end = std::unique(begin(holder_copy), end(holder_copy));\n                        if(uq_end == end(holder_copy))\n                            res_set.insert(std::move(holder_copy));\n                    }\n                    if(sum > n)\n                    {\n                        holder[pos] = 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    to_ignore.push_back(holder[pos]);\n                    increment_holder(pos+1, to_ignore);\n                }\n                do\n                {\n                    ++i, ++holder[pos];\n                } while(std::count(begin(to_ignore), end(to_ignore),holder[pos]));\n                \n                if(i == iter_max)\n                {\n                    holder[pos] = 1;\n                    break;\n                }\n                \n                     \n            }\n        };\n        \n        increment_holder(0, {});\n\n        std::copy(res_set.begin(), res_set.end(), back_inserter(res));\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "combination-sum-iii",
                        "submissions": {
                            "cpp": "394739401"
                        }
                    }
                },
                {
                    "name": "Compare Version Numbers",
                    "link": "https://leetcode.com/problems/compare-version-numbers",
                    "description": "<p>Given two version numbers,&nbsp;<code>version1</code> and <code>version2</code>, compare them.</p>\n\n<ul>\n</ul>\n\n<p>Version numbers consist of <strong>one or more revisions</strong> joined by a dot&nbsp;<code>&#39;.&#39;</code>. Each revision&nbsp;consists of <strong>digits</strong>&nbsp;and may contain leading <strong>zeros</strong>. Every revision contains <strong>at least one character</strong>. Revisions are <strong>0-indexed from left to right</strong>, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example&nbsp;<code>2.5.33</code>&nbsp;and&nbsp;<code>0.1</code>&nbsp;are valid version numbers.</p>\n\n<p>To compare version numbers, compare their revisions in <strong>left-to-right order</strong>. Revisions are compared using their&nbsp;<strong>integer value ignoring any leading zeros</strong>. This means that revisions&nbsp;<code>1</code>&nbsp;and&nbsp;<code>001</code>&nbsp;are considered&nbsp;<strong>equal</strong>. If a version number does not specify a revision at an index, then&nbsp;<strong>treat the revision as&nbsp;<code>0</code></strong>. For example, version&nbsp;<code>1.0</code> is less than version&nbsp;<code>1.1</code>&nbsp;because their revision 0s are the same, but their revision 1s are&nbsp;<code>0</code>&nbsp;and&nbsp;<code>1</code>&nbsp;respectively, and&nbsp;<code>0 &lt; 1</code>.</p>\n\n<p><em>Return the following:</em></p>\n\n<ul>\n\t<li>If <code>version1 &lt; version2</code>, return <code>-1</code>.</li>\n\t<li>If <code>version1 &gt; version2</code>, return <code>1</code>.</li>\n\t<li>Otherwise, return <code>0</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Ignoring leading zeroes, both &quot;01&quot; and &quot;001&quot; represent the same integer &quot;1&quot;.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> version1 does not specify revision 2, which means it is treated as &quot;0&quot;.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>&nbsp;version1&#39;s revision 0 is &quot;0&quot;, while version2&#39;s revision 0 is &quot;1&quot;. 0 &lt; 1, so version1 &lt; version2.\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;\n<strong>Output:</strong> -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>\n\t<li><code>version1</code> and <code>version2</code>&nbsp;only contain digits and <code>&#39;.&#39;</code>.</li>\n\t<li><code>version1</code> and <code>version2</code>&nbsp;<strong>are valid version numbers</strong>.</li>\n\t<li>All the given revisions in&nbsp;<code>version1</code> and <code>version2</code>&nbsp;can be stored in&nbsp;a&nbsp;<strong>32-bit integer</strong>.</li>\n</ul>\n",
                    "solutions": {
                        "python": [
                            {
                                "language": "python",
                                "code": "class Solution:\n    def compareVersion(self, v1: str, v2: str) -> int:\n        for a, b in zip(v1.split('.'), v2.split('.')):\n            if (int(a) != int(b)):\n                return -1 if int(a) < int(b) else 1\n        \n        v1_d, v2_d = v1.strip(\".0\").count('.'), v2.strip(\".0\").count('.')\n        if(v1_d  != v2_d):\n            return -1 if v1_d < v2_d else 1\n\n        return 0\n            \n        "
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "compare-version-numbers",
                        "submissions": {
                            "python": "393625106"
                        }
                    }
                },
                {
                    "name": "Counting Bits",
                    "link": "https://leetcode.com/problems/counting-bits",
                    "description": "<p>Given a non negative integer number <b>num</b>. For every numbers <b>i</b> in the range <b>0 &le; i &le; num</b> calculate the number of 1&#39;s in their binary representation and return them as an array.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[0,1,1]</span></pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">5</span>\r\n<strong>Output: </strong><code>[0,1,1,2,1,2]</code>\r\n</pre>\r\n\r\n<p><b>Follow up:</b></p>\r\n\r\n<ul>\r\n\t<li>It is very easy to come up with a solution with run time <b>O(n*sizeof(integer))</b>. But can you do it in linear time <b>O(n)</b> /possibly in a single pass?</li>\r\n\t<li>Space complexity should be <b>O(n)</b>.</li>\r\n\t<li>Can you do it like a boss? Do it without using any builtin function like <b>__builtin_popcount</b> in c++ or in any other language.</li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    vector<int> countBits(int num)\n    {\n        vector<int> res(num+1);\n        \n        for(int i = 0; i <= num; ++i)\n            res[i] = __builtin_popcount(i);\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "counting-bits",
                        "submissions": {
                            "cpp": "405199505"
                        }
                    }
                },
                {
                    "name": "Course Schedule II",
                    "link": "https://leetcode.com/problems/course-schedule-ii",
                    "description": "<p>There are a total of <code>n</code> courses you have to take labelled from <code>0</code> to <code>n - 1</code>.</p>\n\n<p>Some courses may have <code>prerequisites</code>, for example, if&nbsp;<code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;this means you must take the course <code>b<sub>i</sub></code> before the course <code>a<sub>i</sub></code>.</p>\n\n<p>Given the total number of courses&nbsp;<code>numCourses</code> and a list of the <code>prerequisite</code> pairs, return the ordering of courses you should take to finish all courses.</p>\n\n<p>If there are many valid answers, return <strong>any</strong> of them.&nbsp;If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>Output:</strong> [0,2,1,3]\n<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 1, prerequisites = []\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;=&nbsp;prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;&nbsp;numCourses</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;!=&nbsp;b<sub>i</sub></code></li>\n\t<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <memory>\n#include <functional>\n\nstruct Course\n{\n    int id;\n    bool learned = false;\n    vector<Course*> depends_on;\n    \n    Course(int i):id(i), learned(false){}\n};\n\nclass Solution\n{\n    bool found_loop(Course *start, Course *course_to_check, int len, int current_len)\n    {\n        \n        if(current_len > len)\n            return true;\n        for(auto* course : start->depends_on)\n        {   if(course == course_to_check)\n                return true;\n            if(found_loop(course, course_to_check, len, current_len+1))\n                return true;\n        }\n        return false;\n    }\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites)\n    {\n        vector<Course*> courses;\n        for(int i = 0; i < numCourses; ++i)\n            courses.push_back(new Course(i));\n        \n        //copy graph from input\n        Course *dependancy_tree = nullptr; \n        for(auto p : prerequisites)\n            courses[p[0]]->depends_on.push_back(courses[p[1]]); \n\n        //function to mark learned couses in order \n        vector<int> res;\n        std::function<void(int)> learn_course = [&courses, &res, &learn_course](int id)\n        {\n            if(courses[id]->learned)\n                return;\n            \n            for(auto* course : courses[id]->depends_on)\n                learn_course(course->id);\n            \n            courses[id]->learned = true;\n            res.push_back(id);\n        };\n        \n        //check for loops\n        for(auto* c : courses)\n        if(found_loop(c, c, courses.size(), 1))\n            return  vector<int>{};\n        for(auto* c : courses)\n            learn_course(c->id);\n        for(auto* c : courses)\n            delete c;\n        \n        return res.size() == courses.size() ? res : vector<int>{}; \n\n        \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "course-schedule-ii",
                        "submissions": {
                            "cpp": "368395107"
                        }
                    }
                },
                {
                    "name": "Design Linked List",
                    "link": "https://leetcode.com/problems/design-linked-list",
                    "description": "<p>Design your&nbsp;implementation of the linked list. You can choose to use a singly or doubly linked list.<br />\nA node in a singly&nbsp;linked list should have two attributes: <code>val</code>&nbsp;and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code>&nbsp;is&nbsp;a&nbsp;pointer/reference to the next node.<br />\nIf you want to use the doubly linked list,&nbsp;you will need&nbsp;one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p>\n\n<p>Implement the <code>MyLinkedList</code>&nbsp;class:</p>\n\n<ul>\n\t<li><code>MyLinkedList()</code>&nbsp;Initializes&nbsp;the&nbsp;<code>MyLinkedList</code> object.</li>\n\t<li><code>int get(int index)</code>&nbsp;Get the value of&nbsp;the <code>index<sup>th</sup></code>&nbsp;node in the linked list. If the index is invalid, return <code>-1</code>.</li>\n\t<li><code>void addAtHead(int val)</code>&nbsp;Add a node of value <code>val</code>&nbsp;before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>\n\t<li><code>void addAtTail(int val)</code>&nbsp;Append a node of value <code>val</code>&nbsp;as the last element of the linked list.</li>\n\t<li><code>void addAtIndex(int index, int val)</code>&nbsp;Add a node of value <code>val</code>&nbsp;before the <code>index<sup>th</sup></code>&nbsp;node in the linked list.&nbsp;If <code>index</code>&nbsp;equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li>\n\t<li><code>void deleteAtIndex(int index)</code>&nbsp;Delete&nbsp;the <code>index<sup>th</sup></code>&nbsp;node in the linked list, if the index is valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n<strong>Output</strong>\n[null, null, null, null, 2, null, 3]\n\n<strong>Explanation</strong>\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // return 2\nmyLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3\nmyLinkedList.get(1);              // return 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= index, val &lt;= 1000</code></li>\n\t<li>Please do not use the built-in LinkedList library.</li>\n\t<li>At most <code>2000</code>&nbsp;calls will be made to&nbsp;<code>get</code>,&nbsp;<code>addAtHead</code>,&nbsp;<code>addAtTail</code>,&nbsp; <code>addAtIndex</code> and&nbsp;<code>deleteAtIndex</code>.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "struct Node\n{\n    Node(int v) : val(v){}\n    int val;\n    Node *next = nullptr;\n};\n\nclass MyLinkedList\n{\n    Node *head = nullptr,\n         *tail = nullptr;\n    size_t size = 0;\n    \npublic:\n    /** Initialize your data structure here. */\n    MyLinkedList() = default;\n    \n    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n    int get(int index)\n    {\n        if(!size || index > size-1) \n            return -1;\n        \n        Node *asked_node = head;\n        //node at index\n        for(; index != 0; --index)\n            asked_node = asked_node->next;\n        \n        return asked_node->val;\n    }\n    \n    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n    void addAtHead(int val)\n    {\n        Node *new_node = new Node(val);\n        \n        //init\n        if(!head)\n            head = tail = new_node;\n        else\n        {\n            new_node->next = head;\n            head = new_node;\n        }\n        size++;\n    }\n    \n    /** Append a node of value val to the last element of the linked list. */\n    void addAtTail(int val)\n    {\n        Node *new_node = new Node(val);\n        //init\n        if(!head)\n            head = tail = new_node;\n        else\n        {\n            tail->next = new_node;\n            tail = new_node;\n        }\n        size++;\n    }\n    \n    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n    void addAtIndex(int index, int val)\n    {\n        //index should exist\n        // or index == size, it`s push_back\n        if(index > size) \n            return;\n        \n        \n        if(index == 0)\n            addAtHead(val);\n        else if(index == size)\n            addAtTail(val);\n        else\n        {\n            Node *new_node = new Node(val),\n                 //one node before insertion position\n                 *prev_node = head;\n            for(; index != 1; --index)\n                prev_node = prev_node->next;\n            \n            new_node->next = prev_node->next;\n            prev_node->next = new_node;\n            size++;    \n        }\n        \n    }\n    \n    /** Delete the index-th node in the linked list, if the index is valid. */\n    void deleteAtIndex(int index)\n    {\n        //index should exist\n        if(index > size-1) \n            return;\n        \n        \n        if(index == 0)\n        {\n            //delete head\n            Node *head_next = head->next;\n            if(head == tail)\n                tail = nullptr;\n            \n            delete head;\n            head = head_next;\n        }\n        else if(index == size-1)\n        {\n            //delete tail\n            Node *prev_node = head;\n            //get node before index\n            for(; index != 1; --index)\n                prev_node = prev_node->next;\n            \n            prev_node->next = nullptr;\n            delete tail;\n            tail = prev_node;\n        }\n        else\n        {\n            //delete node in the middle\n            Node *prev_node = head;\n            //get node before index\n            for(; index != 1; --index)\n                prev_node = prev_node->next;\n            \n            Node *to_delete = prev_node->next;\n            prev_node->next = to_delete->next;\n            delete to_delete;\n                \n        }\n        size--;\n    }\n};\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList* obj = new MyLinkedList();\n * int param_1 = obj->get(index);\n * obj->addAtHead(val);\n * obj->addAtTail(val);\n * obj->addAtIndex(index,val);\n * obj->deleteAtIndex(index);\n */"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "design-linked-list",
                        "submissions": {
                            "cpp": "402379267"
                        }
                    }
                },
                {
                    "name": "Gas Station",
                    "link": "https://leetcode.com/problems/gas-station",
                    "description": "<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>\r\n\r\n<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>\r\n\r\n<p>Return the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>If there exists a&nbsp;solution, it is guaranteed to be unique.</li>\r\n\t<li>Both input arrays are non-empty and have the same length.</li>\r\n\t<li>Each element in the input arrays is a non-negative integer.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\ngas  = [1,2,3,4,5]\r\ncost = [3,4,5,1,2]\r\n\r\n<strong>Output:</strong> 3\r\n\r\n<strong>Explanation:\r\n</strong>Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\r\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\r\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\r\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\r\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\r\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\r\nTherefore, return 3 as the starting index.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> \r\ngas  = [2,3,4]\r\ncost = [3,4,3]\r\n\r\n<strong>Output:</strong> -1\r\n\r\n<strong>Explanation:\r\n</strong>You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.\r\nLet&#39;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\r\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\r\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\r\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\r\nTherefore, you can&#39;t travel around the circuit once no matter where you start.\r\n</pre>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost)\n    {\n        const size_t gas_num = gas.size();\n        \n        //O(N^2) solution\n        for(int max_index = 0; max_index < gas_num; max_index++)\n        for(int i = 0, gas_tank = 0; i < gas_num; i++)\n        {\n            const size_t index = (max_index + i) % gas_num;\n            gas_tank += gas[index];\n            //if we unable to get to the next station\n            if(gas_tank < cost[index])\n                break;\n            else\n                gas_tank -= cost[index];\n            \n            if(i + 1 == gas_num)\n                return max_index;\n        }\n        return -1;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "gas-station",
                        "submissions": {
                            "cpp": "399620164"
                        }
                    }
                },
                {
                    "name": "Image Overlap",
                    "link": "https://leetcode.com/problems/image-overlap",
                    "description": "<p>You are given two images <code>img1</code> and <code>img2</code>&nbsp;both of size <code>n x n</code>, represented as&nbsp;binary, square matrices of the same size. (A binary matrix has only 0s and 1s as values.)</p>\n\n<p>We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.&nbsp; After, the <em>overlap</em> of this translation is the number of positions that have a 1 in both images.</p>\n\n<p>(Note also that a translation does <strong>not</strong> include any kind of rotation.)</p>\n\n<p>What is the largest possible overlap?</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap1.jpg\" style=\"width: 450px; height: 231px;\" />\n<pre>\n<strong>Input:</strong> img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We slide img1 to right by 1 unit and down by 1 unit.\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step1.jpg\" style=\"width: 450px; height: 105px;\" />\nThe number of positions that have a 1 in both images is 3. (Shown in red)\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step2.jpg\" style=\"width: 450px; height: 231px;\" />\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> img1 = [[1]], img2 = [[1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> img1 = [[0]], img2 = [[0]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == img1.length</code></li>\n\t<li><code>n == img1[i].length</code></li>\n\t<li><code>n == img2.length </code></li>\n\t<li><code>n == img2[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>img1[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n\t<li><code>img2[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    int largestOverlap(vector<vector<int>>& A, vector<vector<int>>& B)\n    {\n        const size_t length = A.size();\n        if(length == 1)\n            return A[0][0] & B[0][0];\n        \n        size_t max_overlap_count = 0;\n        \n        for (int bi_offset = 0; bi_offset < length; ++bi_offset)\n        for (int bj_offset = 0; bj_offset < length; ++bj_offset)\n        {\n            size_t overlap_count_a = 0,\n                   overlap_count_b = 0;\n\n            for (int i_a = 0, i_b = 0+bi_offset; i_b < length; ++i_a, ++i_b)\n                for (int j_a = 0, j_b = 0+bj_offset; j_b < length; ++j_a, ++j_b)\n                {\n                    if(A[i_a][j_a] & B[i_b][j_b]) //move B over A\n                        overlap_count_b++;\n                    if(A[i_b][j_b] & B[i_a][j_a]) //move A over B\n                        overlap_count_a++;\n                }\n            \n            const size_t iteration_max = std::max(overlap_count_a, overlap_count_b);\n            if(iteration_max > max_overlap_count)\n                max_overlap_count = iteration_max;\n        }\n\n        return max_overlap_count;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "image-overlap",
                        "submissions": {
                            "cpp": "391828850"
                        }
                    }
                },
                {
                    "name": "Insert Interval",
                    "link": "https://leetcode.com/problems/insert-interval",
                    "description": "<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>\n\n<p>You may assume that the intervals were initially sorted according to their start times.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval <code>[4,8]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [], newInterval = [5,7]\n<strong>Output:</strong> [[5,7]]\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,5]], newInterval = [2,3]\n<strong>Output:</strong> [[1,5]]\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,5]], newInterval = [2,7]\n<strong>Output:</strong> [[1,7]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;=&nbsp;intervals[i][0] &lt;=&nbsp;intervals[i][1] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code>&nbsp;is sorted by <code>intervals[i][0]</code> in <strong>ascending</strong>&nbsp;order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;=&nbsp;newInterval[0] &lt;=&nbsp;newInterval[1] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval)\n    {\n        //input check\n        if(intervals.empty())\n            return {newInterval};\n\n        vector<vector<int>> res;\n        res.reserve(intervals.size() + 1);\n        int a = newInterval[0], b = newInterval[1]; \n        \n        //find interval that could be altered to contain newInterval\n        auto iter = begin(intervals),\n                    iter_end = end(intervals);\n        for(;iter < iter_end; ++iter)\n        {\n            int &x1 = iter->at(0), &x2 = iter->at(1);\n            \n            //booster to find correct element\n            if(a > x1 && a > x2 && next(iter) != iter_end)\n            {\n                res.emplace_back(*iter);\n                continue;\n            }\n            break;\n        }\n        \n        //return {*iter};\n        //alter this interval or insert new before interval it\n        {\n            int &x1 = iter->at(0), &x2 = iter->at(1);\n            \n            //(x1,a,b,x2) fully included\n            if( x1 <= a && b <= x2 )\n                return intervals;\n            //(a,x1,x2,b) fully included\n            if( a <= x1 && x2 <= b )\n            {\n                *iter = newInterval;\n            }\n            else if( a == x2 )\n            {\n                x2 = b;\n            }\n            //(a,x1,b,x2)\n            else if( a < x1  && x1 <= b )\n            {\n                x1 = a;\n            }\n            //(x1,a,x2,b)\n            else if( a <= x2 && x2 < b)\n            {\n                x2 = b;\n            }\n            //(a,b,x1,x2) //we can insert a new interval right before iter\n            else if(x1 >= b)\n            {\n                iter = intervals.insert(iter, newInterval);//insert whole interval at prev pos\n            }\n            else if(next(iter) == iter_end)\n            {\n                if(a <= x2)\n                    x2 = b;\n                else\n                {\n                    res.emplace_back(*iter);\n                    iter = intervals.insert(iter_end, newInterval);\n                }\n            }\n\n        }\n\n        //return {*iter};\n\n\n        //check that intervals after modified/inserted one are not overlaping\n        a = iter->at(0), b = iter->at(1);\n        iter_end = end(intervals);\n        auto finish_iter = next(iter);\n        \n        if(finish_iter != iter_end)\n        for(;next(finish_iter) != iter_end; finish_iter++)\n        {\n            int &x1 = finish_iter->at(0), &x2 = finish_iter->at(1);\n            if(b == x1 ||  b <= x2)\n            {\n                break;\n            }\n            if( b < next(finish_iter)->at(0))   \n            {\n                break;\n            }\n        }\n\n        //take right valur from last overlapping\n        if(finish_iter != iter_end)\n        {\n            int &x1 = finish_iter->at(0), &x2 = finish_iter->at(1);\n            if(b >= x1)\n            {\n                if(x2 > b)\n                    iter->at(1) = x2;\n                finish_iter++;\n            }\n        }\n\n        //at this point we finished with our interval,\n        //all other intervals after it is not overlapping\n        res.emplace_back(*iter);\n        for(;finish_iter != iter_end; finish_iter++)\n            res.emplace_back(*finish_iter);\n        \n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "insert-interval",
                        "submissions": {
                            "cpp": "395997637"
                        }
                    }
                },
                {
                    "name": "Insert into a Binary Search Tree",
                    "link": "https://leetcode.com/problems/insert-into-a-binary-search-tree",
                    "description": "<p>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>\n\n<p><strong>Notice</strong>&nbsp;that there may exist&nbsp;multiple valid ways for the&nbsp;insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg\" style=\"width: 752px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3], val = 5\n<strong>Output:</strong> [4,2,7,1,3,5]\n<strong>Explanation:</strong> Another accepted tree is:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/bst.jpg\" style=\"width: 352px; height: 301px;\" />\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [40,20,60,10,30,50,70], val = 25\n<strong>Output:</strong> [40,20,60,10,30,50,70,null,null,25]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n<strong>Output:</strong> [4,2,7,1,3,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in&nbsp;the tree will be in the range <code>[0,&nbsp;10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>8</sup> &lt;= Node.val &lt;= 10<sup>8</sup></code></li>\n\t<li>All the values <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>-10<sup>8</sup> &lt;= val &lt;= 10<sup>8</sup></code></li>\n\t<li>It&#39;s <strong>guaranteed</strong> that <code>val</code> does not exist in the original BST.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution\n{\npublic:\n    TreeNode* insertIntoBST(TreeNode *root, int val)\n    {\n        TreeNode *new_node = new TreeNode(val);\n\n        if(!root)\n            return new_node;\n        \n        TreeNode *&child_node = val < root->val ? root->left : root->right;\n\n        if(child_node)\n            insertIntoBST(child_node, val);\n        else\n            child_node = new_node;\n        \n        return root;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "insert-into-a-binary-search-tree",
                        "submissions": {
                            "cpp": "405182072"
                        }
                    }
                },
                {
                    "name": "K-diff Pairs in an Array",
                    "link": "https://leetcode.com/problems/k-diff-pairs-in-an-array",
                    "description": "<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the number of <b>unique</b> k-diff pairs in the array</em>.</p>\n\n<p>A <b>k-diff</b> pair is&nbsp;an integer pair <code>(nums[i], nums[j])</code>, where the following are true:</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt; nums.length</code></li>\n\t<li><code>i != j</code></li>\n\t<li><code>a &lt;= b</code></li>\n\t<li><code>b - a == k</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,4,1,5], k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of <strong>unique</strong> pairs.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5], k = 1\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,1,5,4], k = 0\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> There is one 0-diff pair in the array, (1, 1).\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,4,4,3,3,0,9,2,3], k = 3\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3], k = 1\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    int findPairs(vector<int>& nums, int k)\n    {\n        size_t count = 0;\n        //O(n) solution, special case for k == 0\n        if(k == 0)\n        {\n            //num, number of entries\n            std::unordered_map<int, size_t> num_of_entries;\n            for(int num : nums)\n                num_of_entries[num]++;\n            \n            for(auto &entrie : num_of_entries)\n                if(entrie.second > 1)\n                    ++count;\n            \n            return count;\n        }\n        \n        //O(n) solution for k > 0\n        //for O(1) lookups if element is present, O(N) extra space\n        std::unordered_set<int> lookup(begin(nums), end(nums));\n        //iterate set to check only 'unique' pairs\n        for(int num : lookup)\n            if(lookup.find(num+k) != end(lookup))\n                ++count;\n        \n        return count;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "k-diff-pairs-in-an-array",
                        "submissions": {
                            "cpp": "404062711"
                        }
                    }
                },
                {
                    "name": "Kth Largest Element in an Array",
                    "link": "https://leetcode.com/problems/kth-largest-element-in-an-array",
                    "description": "<p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[3,2,1,5,6,4] </code>and k = 2\r\n<strong>Output:</strong> 5\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> <code>[3,2,3,1,2,4,5,5,6] </code>and k = 4\r\n<strong>Output:</strong> 4</pre>\r\n\r\n<p><strong>Note: </strong><br />\r\nYou may assume k is always valid, 1 &le; k &le; array&#39;s length.</p>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k)\n    {\n        std::sort(nums.begin(), nums.end());\n        return nums[nums.size()-k];\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "kth-largest-element-in-an-array",
                        "submissions": {
                            "cpp": "380350603"
                        }
                    }
                },
                {
                    "name": "Longest Substring Without Repeating Characters",
                    "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
                    "description": "<p>Given a string <code>s</code>, find the length of the <b>longest substring</b> without repeating characters.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcbb&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;abc&quot;, with the length of 3.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbbbb&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The answer is &quot;b&quot;, with the length of 1.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pwwkew&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;wke&quot;, with the length of 3.\nNotice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        if(s.empty())\n            return 0;\n\n        int res = 0;\n        string substr = \"\";\n        for(char ch : s)\n        {\n            auto ch_in_res_indx = substr.find(ch);\n            if(ch_in_res_indx == std::string::npos)\n                substr.push_back(ch);\n            else\n            {\n                if(substr.size() > res)\n                    res = substr.size();\n                substr.erase(substr.begin(), substr.begin()+ch_in_res_indx+1);\n                substr.push_back(ch);\n            }\n        }\n        \n        if(substr.size() > res)\n                    res = substr.size();\n        return res;\n        \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "longest-substring-without-repeating-characters",
                        "submissions": {
                            "cpp": "349101444"
                        }
                    }
                },
                {
                    "name": "Lowest Common Ancestor of a Binary Tree",
                    "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree",
                    "description": "<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\r\n\r\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes p&nbsp;and q&nbsp;as the lowest node in T that has both p&nbsp;and q&nbsp;as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>\r\n\r\n<p>Given the following binary tree:&nbsp; root =&nbsp;[3,5,1,6,2,0,8,null,null,7,4]</p>\r\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\r\n<strong>Output:</strong> 3\r\n<strong>Explanation: </strong>The LCA of nodes <code>5</code> and <code>1</code> is <code>3.</code>\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\r\n<strong>Output:</strong> 5\r\n<strong>Explanation: </strong>The LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself according to the LCA definition.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All of the nodes&#39; values will be unique.</li>\r\n\t<li>p and q are different and both values will&nbsp;exist in the binary tree.</li>\r\n</ul>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    \n    bool has_element(TreeNode* el, TreeNode* p)\n    {\n        if(el == nullptr)\n            return false;\n        if(el == p)\n            return true;\n        else\n            return has_element(el->right, p) || has_element(el->left, p);\n    }\n    \n\n    \n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)\n    {\n        if(!root) \n            return nullptr;\n\n        if (has_element(root, p) && has_element(root, q))\n        {\n            if(has_element(root->right, p) && has_element(root->right, q))\n                return lowestCommonAncestor(root->right, p, q);\n            else if(has_element(root->left, p) && has_element(root->left, q))\n                return lowestCommonAncestor(root->left, p, q);\n            else return root;\n        }\n        else\n            return nullptr;\n                \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "lowest-common-ancestor-of-a-binary-tree",
                        "submissions": {
                            "cpp": "304530638"
                        }
                    }
                },
                {
                    "name": "Majority Element II",
                    "link": "https://leetcode.com/problems/majority-element-ii",
                    "description": "<p>Given an integer array of size <code>n</code>, find all elements that appear more than <code>&lfloor; n/3 &rfloor;</code> times.</p>\n\n<p><strong>Follow-up: </strong>Could you solve the problem&nbsp;in linear time and in O(1) space?</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,3]\n<strong>Output:</strong> [3]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    vector<int> majorityElement(vector<int>& nums)\n    {\n        std::map<int, size_t> marks;\n        \n        for(auto &num : nums)\n            marks[num]++;\n        \n        const int limit = nums.size() / 3;\n        vector<int> res;\n        \n        for(auto &mark : marks)\n            if(mark.second > limit)\n                res.push_back(mark.first);\n        \n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "majority-element-ii",
                        "submissions": {
                            "cpp": "399126393"
                        }
                    }
                },
                {
                    "name": "Maximum Product Subarray",
                    "link": "https://leetcode.com/problems/maximum-product-subarray",
                    "description": "<p>Given an integer array&nbsp;<code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [2,3,-2,4]\r\n<strong>Output:</strong> <code>6</code>\r\n<strong>Explanation:</strong>&nbsp;[2,3] has the largest product 6.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> [-2,0,-1]\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong>&nbsp;The result cannot be 2, because [-2,-1] is not a subarray.</pre>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <functional>\nclass Solution\n{\npublic:\n    int maxProduct(vector<int>& nums)\n    {\n        //case for 1 number\n        if(nums.size() == 1)\n            return nums[0];\n\n        //erase consecutive 1 an -1\n        bool removed_ones = true;\n        if(nums.size() > 50)\n        while(removed_ones)\n        {\n            removed_ones = false;\n            for(auto iter = nums.begin()++; iter != nums.end()-2;)\n            {\n                int val = *iter;\n                if(\n                    (val == 1 || val == -1) &&\n                        val == *next(iter)  ||\n                    (val == 1 || val == -1) && \n                        (*next(iter) == val*-1 && *prev(iter) ==  val*-1 ) )             \n                {\n                    iter = nums.erase(iter);\n                    removed_ones = true;\n                }\n                else\n                   ++iter;\n\n            }\n        }\n\n        int max = 0;\n        for(auto begin_iter = nums.begin(); begin_iter < nums.end(); ++begin_iter)\n        {\n            int product = *begin_iter,\n                new_product = *begin_iter;\n           \n            for(auto current_iter = next(begin_iter);\n                current_iter < nums.end();\n                current_iter++)\n            {\n                new_product *= *current_iter;\n                if(new_product > product)\n                    product = new_product;\n            }\n            \n            if(product > max) max = product;\n        }\n        \n        return max;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "maximum-product-subarray",
                        "submissions": {
                            "cpp": "394510521"
                        }
                    }
                },
                {
                    "name": "Minimum Number of Arrows to Burst Balloons",
                    "link": "https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons",
                    "description": "<p>There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it&#39;s horizontal, y-coordinates don&#39;t matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.</p>\r\n\r\n<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with <code>x<sub>start</sub></code> and <code>x<sub>end</sub></code> bursts by an arrow shot at <code>x</code> if <code>x<sub>start</sub> &le; x &le; x<sub>end</sub></code>. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.</p>\r\n\r\n<p>Given an array <code>points</code> where <code>points[i] = [x<sub>start</sub>, x<sub>end</sub>]</code>, return&nbsp;<em>the minimum number of arrows that must be shot to burst all balloons</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> points = [[10,16],[2,8],[1,6],[7,12]]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> points = [[1,2],[3,4],[5,6],[7,8]]\r\n<strong>Output:</strong> 4\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> points = [[1,2],[2,3],[3,4],[4,5]]\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> points = [[1,2]]\r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> points = [[2,3],[2,3]]\r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>0 &lt;= points.length &lt;= 10<sup>4</sup></code></li>\r\n\t<li><code>points.length == 2</code></li>\r\n\t<li><code>-2<sup>31</sup> &lt;= x<sub>start</sub> &lt;&nbsp;x<sub>end</sub> &lt;= 2<sup>31</sup> - 1</code></li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\n    enum {START, END};\n\npublic:\n    //O(n log n) solution, because of sorting\n    //sort intervals by END, (wider first if ENDs are the same)\n    //and check for overlaps with current->at(END) < next_iter->at(START)\n    int findMinArrowShots(vector<vector<int>>& points)\n    {\n        //sort by END value, if equal: put wider intervals first\n        std::sort(begin(points), end(points),\n                  [](auto a, auto b)\n                  {\n                      return a[END] == b[END] ? \n                      a[START] > b[START] :\n                      a[END] < b[END];\n                  });\n        \n        int arrow_num = 0;\n        for(auto current = begin(points); current != end(points);)\n        {\n            //count all intervals that overlaps with current\n            //still O(n) because we moving forward in vector\n            for(auto next_iter = next(current); ; ++next_iter)\n            {\n                if(next_iter == end(points) || \n                   current->at(END) < next_iter->at(START))\n                {\n                    arrow_num++;\n                    current = next_iter;\n                    break;\n                }\n                //else there is overlap with current\n            }\n        }\n        \n        return arrow_num;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "minimum-number-of-arrows-to-burst-balloons",
                        "submissions": {
                            "cpp": "407056650"
                        }
                    }
                },
                {
                    "name": "Random Point in Non-overlapping Rectangles",
                    "link": "https://leetcode.com/problems/random-point-in-non-overlapping-rectangles",
                    "description": "<p>Given a list of <strong>non-overlapping</strong>&nbsp;axis-aligned rectangles <code>rects</code>, write a function <code>pick</code> which randomly and uniformily picks an <strong>integer point</strong> in the space&nbsp;covered by the rectangles.</p>\r\n\r\n<p>Note:</p>\r\n\r\n<ol>\r\n\t<li>An <strong>integer point</strong>&nbsp;is a point that has integer coordinates.&nbsp;</li>\r\n\t<li>A point&nbsp;on the perimeter&nbsp;of a rectangle is&nbsp;<strong>included</strong> in the space covered by the rectangles.&nbsp;</li>\r\n\t<li><code>i</code>th rectangle = <code>rects[i]</code> =&nbsp;<code>[x1,y1,x2,y2]</code>, where <code>[x1, y1]</code>&nbsp;are the integer coordinates of the bottom-left corner, and <code>[x2, y2]</code>&nbsp;are the integer coordinates of the top-right corner.</li>\r\n\t<li>length and width of each rectangle does not exceed <code>2000</code>.</li>\r\n\t<li><code>1 &lt;= rects.length&nbsp;&lt;= 100</code></li>\r\n\t<li><code>pick</code> return a point as an array of integer coordinates&nbsp;<code>[p_x, p_y]</code></li>\r\n\t<li><code>pick</code> is called at most <code>10000</code>&nbsp;times.</li>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-1-1\">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]\r\n</span><span id=\"example-input-1-2\">[[[[1,1,5,5]]],[],[],[]]</span>\r\n<strong>Output: \r\n</strong><span id=\"example-output-1\">[null,[4,1],[4,1],[3,3]]</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: \r\n</strong><span id=\"example-input-2-1\">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]\r\n</span><span id=\"example-input-2-2\">[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]</span>\r\n<strong>Output: \r\n</strong><span id=\"example-output-2\">[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]</span></pre>\r\n</div>\r\n\r\n<div>\r\n<p><strong>Explanation of Input Syntax:</strong></p>\r\n\r\n<p>The input is two lists:&nbsp;the subroutines called&nbsp;and their&nbsp;arguments.&nbsp;<code>Solution</code>&#39;s&nbsp;constructor has one argument, the array of rectangles <code>rects</code>. <code>pick</code>&nbsp;has no arguments.&nbsp;Arguments&nbsp;are&nbsp;always wrapped with a list, even if there aren&#39;t any.</p>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<div>&nbsp;</div>\r\n</div>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <cstdlib>\n#include <cmath>\n#include <time.h>\n\nclass Solution\n{\n    struct rect_info\n    {\n        const size_t start, end;\n        const int length, height;\n        vector<int>& rect;\n    };\n    \n    size_t total_num_of_points = 0;    \n    vector<vector<int>>& _rects;\n    vector<rect_info> _rect_infos;\n        \npublic:\n    Solution(vector<vector<int>>& rects) : _rects(rects)\n    {\n        srand(time(NULL));\n        \n        for(auto &rect : _rects)\n        {\n            const int\n                length = abs(rect[2] - rect[0]), //x2 - x1 \n                height = abs(rect[3] - rect[1]); //y2 - y1\n            size_t rec_num_of_points = (length+1)*(height+1);\n            \n            _rect_infos.push_back({total_num_of_points, total_num_of_points + rec_num_of_points,\n                                     length, height, rect});\n            \n            total_num_of_points += rec_num_of_points;\n        }\n    }\n    \n    vector<int> pick()\n    {\n        //select random rect\n        size_t point_index = rand()%total_num_of_points;\n        rect_info *ri = nullptr;\n        for(auto &r_info : _rect_infos)\n        {\n            if(r_info.start <= point_index && point_index < r_info.end)   \n            {\n                ri = &r_info;\n                break;\n            }\n        }\n\n        //select random point \n       const int\n            x_offset = ri->length ? rand()%(ri->length+1) : 0,\n            y_offset = ri->height ? rand()%(ri->height+1) : 0;\n\n        return { ri->rect[0] + x_offset, ri->rect[1] + y_offset};        \n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(rects);\n * vector<int> param_1 = obj->pick();\n */"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "random-point-in-non-overlapping-rectangles",
                        "submissions": {
                            "cpp": "384586283"
                        }
                    }
                },
                {
                    "name": "Remove Covered Intervals",
                    "link": "https://leetcode.com/problems/remove-covered-intervals",
                    "description": "<p>Given a list of <code>intervals</code>, remove all intervals that are covered by another interval in the list.</p>\r\n\r\n<p>Interval <code>[a,b)</code> is covered by&nbsp;interval <code>[c,d)</code> if and only if <code>c &lt;= a</code> and <code>b &lt;= d</code>.</p>\r\n\r\n<p>After doing so, return <em>the number of remaining intervals</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> intervals = [[1,4],[3,6],[2,8]]\r\n<strong>Output:</strong> 2\r\n<b>Explanation: </b>Interval [3,6] is covered by [2,8], therefore it is removed.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> intervals = [[1,4],[2,3]]\r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> intervals = [[0,10],[5,12]]\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> intervals = [[3,10],[4,10],[5,11]]\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> intervals = [[1,2],[1,4],[3,4]]\r\n<strong>Output:</strong> 1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= intervals.length &lt;= 1000</code></li>\r\n\t<li><code>intervals[i].length == 2</code></li>\r\n\t<li><code>0 &lt;= intervals[i][0] &lt;&nbsp;intervals[i][1] &lt;= 10^5</code></li>\r\n\t<li>All the intervals are <strong>unique</strong>.</li>\r\n</ul>",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\n    enum {START, END};\n\npublic:\n    \n    //O(n log n) solution: sort + 1 pass\n    int removeCoveredIntervals(vector<vector<int>>& intervals)\n    {\n        std::sort(begin(intervals), end(intervals),\n                 [](auto a, auto b)\n                 {\n                   return a[END] == b[END] ? a[START] > b[START] : a[END] < b[END];  \n                 }\n                 );\n        \n        //copy data to list for O(1) erasure\n        std::list<vector<int>> i_vals(begin(intervals), end(intervals));\n\n        \n        //ENDs is already sorted, so next element has end >= than prev\n        //only thing is to check the start of the interval, if prev has START > next start\n        //then it's covered\n        for(auto iter = begin(i_vals); iter != prev(end(i_vals));)\n        {\n            if((*iter)[START] >= (*next(iter))[START])\n            {\n                iter = i_vals.erase(iter);\n                if(iter != begin(i_vals))\n                    advance(iter, -1);\n            }\n            else\n                ++iter;\n        }\n        \n        return i_vals.size();\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "remove-covered-intervals",
                        "submissions": {
                            "cpp": "404495630"
                        }
                    }
                },
                {
                    "name": "Rotate Array",
                    "link": "https://leetcode.com/problems/rotate-array",
                    "description": "<p>Given an array, rotate the array to the right by <em>k</em> steps, where&nbsp;<em>k</em>&nbsp;is non-negative.</p>\n\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>\n\t<li>Could you do it in-place with O(1) extra space?</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 3\n<strong>Output:</strong> [5,6,7,1,2,3,4]\n<strong>Explanation:</strong>\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-100,3,99], k = 2\n<strong>Output:</strong> [3,99,-1,-100]\n<strong>Explanation:</strong> \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>\n\t<li>It&#39;s guaranteed that <code>nums[i]</code> fits in a 32 bit-signed integer.</li>\n\t<li><code>k &gt;= 0</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <iterator>\n#include <utility>\n#define mmi std::make_move_iterator\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k)\n    {\n        if(nums.size() <= 1)\n            return;\n        if(k > nums.size())\n            k -= nums.size();\n        \n        vector<int> right_chunk(nums.end()-k, nums.end());\n        //mmi is hack after using mmi nums is not valid\n        right_chunk.insert(right_chunk.end(), mmi(nums.begin()), mmi(nums.end()-k));\n        nums = std::move(right_chunk);\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "rotate-array",
                        "submissions": {
                            "cpp": "302356085"
                        }
                    }
                },
                {
                    "name": "Rotate Image",
                    "link": "https://leetcode.com/problems/rotate-image",
                    "description": "<p>You are given an <em>n</em> x <em>n</em> 2D <code>matrix</code> representing an image, rotate the image by 90 degrees (clockwise).</p>\n\n<p>You have to rotate the image <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" style=\"width: 642px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [[7,4,1],[8,5,2],[9,6,3]]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\" style=\"width: 800px; height: 321px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n<strong>Output:</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1]]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1,2],[3,4]]\n<strong>Output:</strong> [[3,1],[4,2]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>matrix.length == n</code></li>\n\t<li><code>matrix[i].length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <cmath>\nclass Solution\n{\n    \n/*\nApproach:\nrotate by layers\nfirst X that Y\nXXXX\nXYYX\nXYYX\nXXXX\n*/\npublic:\n    void rotate(vector<vector<int>>& matrix)\n    {\n        int size = matrix.size();\n        \n        for(int i = 0; i < ceil(size/2.0); ++i)\n            for(int j = i; j < (size-i*2)-1+i; ++j)\n            {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[size-1-j][i];\n                matrix[size-1-j][i] = matrix[size-1-i][size-1-j];\n                matrix[size-1-i][size-1-j] = matrix[j][size-1-i];\n                matrix[j][size-1-i] = temp;\n            }\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "rotate-image",
                        "submissions": {
                            "cpp": "301747120"
                        }
                    }
                },
                {
                    "name": "Rotate List",
                    "link": "https://leetcode.com/problems/rotate-list",
                    "description": "<p>Given a linked&nbsp;list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2\r\n<strong>Output:</strong> 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL\r\n<strong>Explanation:</strong>\r\nrotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL\r\nrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> 0-&gt;1-&gt;2-&gt;NULL, k = 4\r\n<strong>Output:</strong> <code>2-&gt;0-&gt;1-&gt;NULL</code>\r\n<strong>Explanation:</strong>\r\nrotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL\r\nrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL\r\nrotate 3 steps to the right:&nbsp;<code>0-&gt;1-&gt;2-&gt;NULL</code>\r\nrotate 4 steps to the right:&nbsp;<code>2-&gt;0-&gt;1-&gt;NULL</code></pre>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution\n{\npublic:\n    //O(n)solution with circular list\n    ListNode* rotateRight(ListNode* head, int k)\n    {\n        if(!head)\n            return head;\n        \n        //find list length and save tail\n        size_t length = 0;\n        ListNode *tail = nullptr;\n        for(ListNode *counter = head; counter; ++length, counter = counter->next)\n            if(!counter->next)\n                tail = counter;\n        \n        //make list circular\n        tail->next = head;\n        \n        //module k\n        k = k % length;\n        \n        //we will move k last element to front\n        //length - k element will be a new tail\n        //length - k + 1 element will be a new head\n        \n        //find new tail:\n        tail = head;\n        for(int i = 0; i < length - k - 1; ++i, tail = tail->next);\n        \n        head = tail->next;\n        tail->next = nullptr;\n        \n        return head;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "rotate-list",
                        "submissions": {
                            "cpp": "405650257"
                        }
                    }
                },
                {
                    "name": "Rotting Oranges",
                    "link": "https://leetcode.com/problems/rotting-oranges",
                    "description": "<p>In a given grid, each cell can have one of three&nbsp;values:</p>\r\n\r\n<ul>\r\n\t<li>the value <code>0</code> representing an empty cell;</li>\r\n\t<li>the value <code>1</code> representing a fresh orange;</li>\r\n\t<li>the value <code>2</code> representing a rotten orange.</li>\r\n</ul>\r\n\r\n<p>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>\r\n\r\n<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange.&nbsp; If this is impossible, return <code>-1</code> instead.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/16/oranges.png\" style=\"width: 712px; height: 150px;\" /></strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[2,1,1],[1,1,0],[0,1,1]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">4</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[[2,1,1],[0,1,1],[1,0,1]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">-1</span>\r\n<strong>Explanation: </strong> The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[[0,2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">0</span>\r\n<strong>Explanation: </strong> Since there are already no fresh oranges at minute 0, the answer is just 0.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= grid.length &lt;= 10</code></li>\r\n\t<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>\r\n\t<li><code>grid[i][j]</code> is only <code>0</code>, <code>1</code>, or <code>2</code>.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{    \nenum state{empty, fresh, rotten};\npublic:\n    template<state state_to_check>\n    bool is_cell(int i, int j, vector<vector<int>>& grid)\n    {\n        try\n        {\n            return grid.at(i).at(j) == state_to_check;\n        }\n        catch(const std::out_of_range)\n        {\n            return true;\n        }\n    }\n    \n    bool check_siders_is_present(int i, int j, vector<vector<int>>& g)\n    {\n        bool is_present = is_cell<empty>(i,j,g) || is_cell<rotten>(i,j,g) ? true :\n           !(is_cell<empty>(i+1,j,g) && is_cell<empty>(i-1,j,g) \n             && is_cell<empty>(i,j+1,g) && is_cell<empty>(i,j-1,g));\n        return is_present;\n    }\n    \n    int orangesRotting(vector<vector<int>>& g)\n    {\n        //input check\n        //if(g.size() == 1 && g[0].size() ==1 )\n          //  return g[0][0] == rotten ? 0 : -1;\n        \n        //there is no cut off oranges\n        for(int i = 0; i < g.size(); i++)\n        for(int j = 0; j < g[i].size(); j++)\n            if(check_siders_is_present(i,j,g) == false)\n                return -1;\n        \n        //there is at least one rotten\n        bool rotten_is_present = false,\n             fresh_is_present = false;\n        for(auto line : g)\n        {\n            if(count(line.begin(), line.end(), rotten))\n            {\n                rotten_is_present = true;\n            }\n            if(count(line.begin(), line.end(), fresh))\n            {\n                fresh_is_present = true;\n            }\n        }\n        if(!rotten_is_present)\n            return fresh_is_present ? -1 : 0;\n        \n        //start iteration\n        vector<vector<int>> grid(g);\n        queue<pair<int,int>> to_rot;\n        bool all_rotten = false;\n        size_t minutes = 0;\n        \n        auto rot_if_fresh = [&grid, &all_rotten](int i, int j)\n        {\n            try\n            {\n                if (grid.at(i).at(j) == fresh)\n                {\n                    grid[i][j] = rotten;\n                    all_rotten = false;\n                }\n            }\n            catch(const std::out_of_range){}\n        };\n        \n        while(!all_rotten)\n        {\n            all_rotten = true; \n            for(int i = 0; i < grid.size(); i++)\n            for(int j = 0; j < grid[i].size(); j++)\n            {\n                if(grid[i][j] == rotten)\n                    to_rot.push({i,j});\n            }\n            \n            while(!to_rot.empty()) \n            {\n                auto p = to_rot.front(); to_rot.pop();\n                \n                int i = p.first, j = p.second;\n                rot_if_fresh(i+1,j);\n                rot_if_fresh(i-1,j);\n                rot_if_fresh(i,j+1);\n                rot_if_fresh(i,j-1);\n            }\n            \n            if(!all_rotten)\n                minutes++;\n            \n        }\n        \n        fresh_is_present = false;\n        for(auto line : grid)\n        if(count(line.begin(), line.end(), fresh))\n        {\n            fresh_is_present = true;\n        }\n        return fresh_is_present ? -1 : minutes;\n\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "rotting-oranges",
                        "submissions": {
                            "cpp": "378494170"
                        }
                    }
                },
                {
                    "name": "Serialize and Deserialize BST",
                    "link": "https://leetcode.com/problems/serialize-and-deserialize-bst",
                    "description": "<p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n\n<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>\n\n<p><b>The encoded string should be as compact as possible.</b></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,1,3]\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>\n</ul>\n",
                    "solutions": {
                        "python": [
                            {
                                "language": "python",
                                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n# O(N) Solution with pre-order traversal\n# first element is the root,\n# all elements that are less than root are left part of tree\n# bigger is right, process left and right recursively\nclass Codec:\n\n    def serialize(self, root: TreeNode) -> str:\n        \"\"\"Encodes a tree to a single string.\n        \"\"\"\n        if root is None:\n            return \"\"\n        else:\n            return str(root.val) + \";\" + self.serialize(root.left) + self.serialize(root.right)\n        \n\n    def deserialize(self, data: str) -> TreeNode:\n        \"\"\"Decodes your encoded data to tree.\n        \"\"\"\n        if data == \"\":\n            return None\n\n        nodes = data.split(';')\n        root = TreeNode(int(nodes[0]))\n        root.left = \\\n            self.deserialize(';'.join([n for n in nodes[1:] if len(n) and int(n) < root.val]))\n        root.right = \\\n            self.deserialize(';'.join([n for n in nodes[1:] if len(n) and int(n) >= root.val]))\n        \n        return root\n            \n        \n\n# Your Codec object will be instantiated and called as such:\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# tree = ser.serialize(root)\n# ans = deser.deserialize(tree)\n# return ans"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "serialize-and-deserialize-bst",
                        "submissions": {
                            "python": "406690728"
                        }
                    }
                },
                {
                    "name": "String to Integer (atoi)",
                    "link": "https://leetcode.com/problems/string-to-integer-atoi",
                    "description": "<p>Implement <code><span>atoi</span></code> which&nbsp;converts a string to an integer.</p>\n\n<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>\n\n<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>\n\n<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>\n\n<p>If no valid conversion could be performed, a zero value is returned.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Only the space character <code>&#39; &#39;</code> is considered a whitespace character.</li>\n\t<li>Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1]. If the numerical value is out of the range of representable values, INT_MAX (2<sup>31&nbsp;</sup>&minus; 1) or INT_MIN (&minus;2<sup>31</sup>) is returned.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> str = &quot;42&quot;\n<strong>Output:</strong> 42\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> str = &quot;   -42&quot;\n<strong>Output:</strong> -42\n<strong>Explanation:</strong> The first non-whitespace character is &#39;-&#39;, which is the minus sign. Then take as many numerical digits as possible, which gets 42.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> str = &quot;4193 with words&quot;\n<strong>Output:</strong> 4193\n<strong>Explanation:</strong> Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> str = &quot;words and 987&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The first non-whitespace character is &#39;w&#39;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> str = &quot;-91283472332&quot;\n<strong>Output:</strong> -2147483648\n<strong>Explanation:</strong> The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (&minus;2<sup>31</sup>) is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), digits, <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code> and <code>&#39;.&#39;</code>.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <cmath>\n#include <climits>\n\nclass Solution\n{\npublic:\n    int myAtoi(string str)\n    {\n        //check params\n        if(str.empty())\n            return 0;\n\n        //get start position\n        int start_pos = 0;\n        bool number_started = false;\n        for(;str[start_pos] == ' ' && !number_started || str[start_pos] == '0' ; start_pos++)\n            if(str[start_pos] == '0') number_started = true;\n        \n        \n        \n        //validate it\n        bool is_negative = false, is_signed = false;\n        if(str[start_pos] == '-')\n        {\n            is_negative = true;\n            is_signed = true;\n        }\n        else if(str[start_pos] == '+')\n        {\n            is_signed = true;\n        }\n        \n        //no zeroes before sign\n        if(is_signed)\n        {   \n            if(start_pos!=0 && str[start_pos-1] == '0')\n                return 0;\n            //skip sign for compounting\n            start_pos++;\n        }   \n        \n        //remove potential zeros after sign\n        for(;str[start_pos] == '0' ; start_pos++);\n\n        if(str[start_pos] < '0' || str[start_pos] > '9')\n           return 0;\n        \n        \n        //find end\n        int delim_position=start_pos;\n        while(str[++delim_position] >= '0' && str[delim_position] <= '9');\n        \n        //check for limits\n        if( (delim_position - start_pos) > 10)\n            return is_negative ? INT_MIN : INT_MAX;\n        \n        //case for near limit numbers\n        if( (delim_position - start_pos) == 10)\n        {\n            string shorter_input(str.begin()+start_pos, str.begin()+delim_position-1);\n            int shorter_input_value = myAtoi(shorter_input);\n            if ( shorter_input_value > 214748364 \n                || (shorter_input_value == 214748364 && str[delim_position-1] > '7') )\n                return is_negative ? INT_MIN : INT_MAX;\n        }\n        \n        //compound the result\n        int result = 0;\n        for(; start_pos < delim_position; ++start_pos)\n            result += std::pow(10, delim_position - start_pos - 1) \n                      * (str[start_pos] - '0');\n        \n        if(is_negative)\n            result*=-1;\n        \n        return result;\n            \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "string-to-integer-atoi",
                        "submissions": {
                            "cpp": "303919135"
                        }
                    }
                },
                {
                    "name": "Teemo Attacking",
                    "link": "https://leetcode.com/problems/teemo-attacking",
                    "description": "<p>In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo&#39;s attacking <b>ascending</b> time series towards Ashe and the poisoning time duration per Teemo&#39;s attacking, you need to output the total time that Ashe is in poisoned condition.</p>\r\n\r\n<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [1,4], 2\r\n<b>Output:</b> 4\r\n<b>Explanation:</b> At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. \r\nThis poisoned status will last 2 seconds until the end of time point 2. \r\nAnd at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. \r\nSo you finally need to output 4.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [1,2], 2\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. \r\nThis poisoned status will last 2 seconds until the end of time point 2. \r\nHowever, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. \r\nSince the poisoned status won&#39;t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. \r\nSo you finally need to output 3.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>You may assume the length of given time series array won&#39;t exceed 10000.</li>\r\n\t<li>You may assume the numbers in the Teemo&#39;s attacking time series and his poisoning time duration per attacking are non-negative integers, which won&#39;t exceed 10,000,000.</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\npublic:\n    int findPoisonedDuration(vector<int>& time_series, int duration)\n    {\n        unsigned poisoned_time = 0;\n        for(auto strike = begin(time_series); strike < end(time_series); ++strike)\n        {\n            if(next(strike) == end(time_series) || \n               *strike + duration < *next(strike))\n                poisoned_time += duration;\n            else\n                poisoned_time += *next(strike) - *strike;\n        }\n        \n        return poisoned_time;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "teemo-attacking",
                        "submissions": {
                            "cpp": "400999871"
                        }
                    }
                },
                {
                    "name": "Top K Frequent Elements",
                    "link": "https://leetcode.com/problems/top-k-frequent-elements",
                    "description": "<p>Given a non-empty array of integers, return the <b><i>k</i></b> most frequent elements.</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input: </strong>nums = <span id=\"example-input-1-1\">[1,1,1,2,2,3]</span>, k = <span id=\"example-input-1-2\">2</span>\n<strong>Output: </strong><span id=\"example-output-1\">[1,2]</span>\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input: </strong>nums = <span id=\"example-input-2-1\">[1]</span>, k = <span id=\"example-input-2-2\">1</span>\n<strong>Output: </strong><span id=\"example-output-2\">[1]</span></pre>\n</div>\n\n<p><b>Note: </b></p>\n\n<ul>\n\t<li>You may assume <i>k</i> is always valid, 1 &le; <i>k</i> &le; number of unique elements.</li>\n\t<li>Your algorithm&#39;s time complexity <b>must be</b> better than O(<i>n</i> log <i>n</i>), where <i>n</i> is the array&#39;s size.</li>\n\t<li>It&#39;s guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique.</li>\n\t<li>You can return the answer in any order.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <map>\n\nclass Solution\n{\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k)\n    {\n        std::map<int, int> input_map;\n        for(int i : nums)\n            input_map[i]++;\n        \n        //sort by values(freqency)\n        std::multimap<int, int> sorted_input_map;\n        for(auto p : input_map)\n            sorted_input_map.insert({p.second, p.first});\n        \n        vector<int> res;\n        for(auto iter = --sorted_input_map.end(); k--; --iter)\n            res.push_back(iter->second);\n\n        return res;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "top-k-frequent-elements",
                        "submissions": {
                            "cpp": "367910027"
                        }
                    }
                },
                {
                    "name": "Valid Sudoku",
                    "link": "https://leetcode.com/problems/valid-sudoku",
                    "description": "<p>Determine if a&nbsp;9x9 Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;<strong>according to the following rules</strong>:</p>\r\n\r\n<ol>\r\n\t<li>Each row&nbsp;must contain the&nbsp;digits&nbsp;<code>1-9</code> without repetition.</li>\r\n\t<li>Each column must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\r\n\t<li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\r\n</ol>\r\n\r\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" /><br />\r\n<small>A partially filled sudoku which is valid.</small></p>\r\n\r\n<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\r\n  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\r\n  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],\r\n  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],\r\n  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],\r\n  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],\r\n  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],\r\n  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],\r\n  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]\r\n]\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n[\r\n&nbsp; [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\r\n&nbsp; [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],\r\n&nbsp; [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],\r\n&nbsp; [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],\r\n&nbsp; [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],\r\n&nbsp; [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],\r\n&nbsp; [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],\r\n&nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],\r\n&nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]\r\n]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> Same as Example 1, except with the <strong>5</strong> in the top left corner being \r\n    modified to <strong>8</strong>. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\r\n\t<li>Only the filled cells need to be validated according to the mentioned&nbsp;rules.</li>\r\n\t<li>The given board&nbsp;contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li>\r\n\t<li>The given board size is always <code>9x9</code>.</li>\r\n</ul>\r\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <algorithm>\n#include <map>\n\n\nenum SudokuBitmap\n{\n    a1 = 1 << 1,\n    a2 = 1 << 2,\n    a3 = 1 << 3,\n    a4 = 1 << 4,\n    a5 = 1 << 5,\n    a6 = 1 << 6,\n    a7 = 1 << 7,\n    a8 = 1 << 8,\n    a9 = 1 << 9\n};\n\nmap<char, SudokuBitmap> SudokuMap\n{\n{'1',a1},\n{'2',a2},\n{'3',a3},\n{'4',a4},\n{'5',a5},\n{'6',a6},\n{'7',a7},\n{'8',a8},\n{'9',a9}\n};\n\nclass Solution\n{\npublic:\n    bool isValidSudoku(vector<vector<char>>& board)\n    {\n        short flags = 0;\n\n        const auto cell_is_invalid =\n            [&flags, SudokuMap](char a)\n            {\n                \n                if( !(a == '.' || (a > '0' && a < '9'+1)) ) \n                    return true;\n                if(flags & SudokuMap[a])\n                    return true;\n                \n                flags |= SudokuMap[a];\n                return false;\n            };\n        \n\n        //check all rows   \n        for(auto row : board)\n        {\n            flags = 0;\n            bool invalid = count_if(row.begin(), row.end(), cell_is_invalid);\n            if(invalid) return false;\n        }\n        \n        //check all columns\n        for(unsigned i = 0; i < board.size(); ++i)\n        {\n            flags = 0;\n            for(unsigned j = 0; j < board.size(); ++j)\n                if(cell_is_invalid(board[j][i]))\n                    return false;\n        }\n        \n        //check every 3x3\n        for(unsigned i = 0; i < board.size(); i+=3)\n            for(unsigned j = 0; j < board.size(); j+=3)\n            {\n                flags = 0;\n                if(\n                  cell_is_invalid(board[i][j]) ||\n                  cell_is_invalid(board[i][j+1]) ||\n                  cell_is_invalid(board[i][j+2]) ||\n                  cell_is_invalid(board[i+1][j]) ||\n                  cell_is_invalid(board[i+1][j+1]) ||\n                  cell_is_invalid(board[i+1][j+2]) ||\n                  cell_is_invalid(board[i+2][j]) ||\n                  cell_is_invalid(board[i+2][j+1]) ||\n                  cell_is_invalid(board[i+2][j+2])\n                 ) return false;\n            }\n        \n        return true;\n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "valid-sudoku",
                        "submissions": {
                            "cpp": "302056752"
                        }
                    }
                }
            ]
        },
        {
            "name": "\ud83d\udcaa Hard",
            "tasks": [
                {
                    "name": "Median of Two Sorted Arrays",
                    "link": "https://leetcode.com/problems/median-of-two-sorted-arrays",
                    "description": "<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p>\n\n<p><strong>Follow up:</strong> The overall run time complexity should be <code>O(log (m+n))</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,3], nums2 = [2]\n<strong>Output:</strong> 2.00000\n<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]\n<strong>Output:</strong> 2.50000\n<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0,0], nums2 = [0,0]\n<strong>Output:</strong> 0.00000\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [], nums2 = [1]\n<strong>Output:</strong> 1.00000\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [2], nums2 = []\n<strong>Output:</strong> 2.00000\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "#include <algorithm>\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2)\n    {\n        int target_size = nums1.size() + nums2.size();\n        vector<int> combined(target_size);\n\n        // SOLUTION A - 48 ms\t89.6 MB\n        copy(nums1.begin(), nums1.end(), combined.begin());\n        copy(nums2.begin(), nums2.end(), combined.begin()+nums1.size());\n        sort(combined.begin(),combined.end());\n        \n\n        // SOLUTION B - 124 ms\t89.6 MB      \n//         for(int i = 0, ni1 = 0, ni2 = 0; i < target_size; ++i)\n//         {\n//             if(ni1 != nums1.size())\n//             if(ni2 == nums2.size() || nums1[ni1] <= nums2[ni2])\n//             {\n//                 combined[i] = nums1[ni1++];\n//                 continue;\n//             }\n            \n//             if(ni2 != nums2.size())\n//             if(ni1 == nums1.size() || nums2[ni2] <= nums1[ni1])\n//             {\n//                 combined[i] = nums2[ni2++];\n//                 continue;\n//             }\n//         }\n        \n        if(target_size % 2)\n            return combined[(target_size/2)];\n        else\n            return (combined[(target_size/2)-1] + combined[(target_size/2)]) / 2.f;\n            \n            \n    }\n};"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "median-of-two-sorted-arrays",
                        "submissions": {
                            "cpp": "349930646"
                        }
                    }
                },
                {
                    "name": "Parsing A Boolean Expression",
                    "link": "https://leetcode.com/problems/parsing-a-boolean-expression",
                    "description": "<p>Return the result of evaluating a given boolean <code>expression</code>, represented as a string.</p>\n\n<p>An expression can either be:</p>\n\n<ul>\n\t<li><code>&quot;t&quot;</code>, evaluating to <code>True</code>;</li>\n\t<li><code>&quot;f&quot;</code>, evaluating to <code>False</code>;</li>\n\t<li><code>&quot;!(expr)&quot;</code>, evaluating to the logical NOT of the inner expression <code>expr</code>;</li>\n\t<li><code>&quot;&amp;(expr1,expr2,...)&quot;</code>, evaluating to the logical AND of 2 or more inner expressions <code>expr1, expr2, ...</code>;</li>\n\t<li><code>&quot;|(expr1,expr2,...)&quot;</code>, evaluating to the logical OR of 2 or more inner expressions <code>expr1, expr2, ...</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;!(f)&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;|(f,t)&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;&amp;(t,f)&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;|(&amp;(t,f,t),!(t))&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 20000</code></li>\n\t<li><code>expression[i]</code>&nbsp;consists of characters in <code>{&#39;(&#39;, &#39;)&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;!&#39;, &#39;t&#39;, &#39;f&#39;, &#39;,&#39;}</code>.</li>\n\t<li><code>expression</code> is a valid expression representing a boolean, as given in the description.</li>\n</ul>\n",
                    "solutions": {
                        "cpp": [
                            {
                                "language": "cpp",
                                "code": "class Solution\n{\n    // IN: string with coma separated BOOL expressions\n    // OUT: list of corresponding BOOL values\n    list<bool> deduceBoolList(string exprs)\n    {\n        list<bool> res;\n\n        const char *c_exprs = exprs.c_str();\n        do\n        {\n            //if we are on coma. step over it\n            if(*c_exprs == ',')\n                c_exprs++;\n\n            //if we have an operator with argumets\n            if(c_exprs[1] == '(')\n            {\n                //to find the end, we must count every ()\n                const char *exp_end = c_exprs+2;\n                size_t active_parentheses_num = 1;\n                while(active_parentheses_num)\n                {\n                    exp_end++;\n                    if(*exp_end == '(')\n                        active_parentheses_num++;\n                    if(*exp_end == ')')\n                        active_parentheses_num--;\n                }\n                \n                //when end is found form string with whole expression\n                string exp(c_exprs, exp_end-c_exprs+1);\n                res.push_back(parseBoolExpr(exp));\n                c_exprs = exp_end+1;\n            }\n            else\n            {\n                string exp(1,*c_exprs);\n                res.push_back(parseBoolExpr(exp));\n            }\n                \n        }\n        while(c_exprs = strchr(c_exprs, ','));\n        \n        return res;\n    }\n    \n    using fbbb = function<bool(bool,bool)>;\n\npublic:\n\n    bool parseBoolExpr(string expression)\n    {\n        if(expression == \"f\")\n            return false;\n        if(expression == \"t\")\n            return true;\n\n         //3 chars: !()\n        string in_parentheses = expression.substr(2, expression.size() - 3);\n\n        //check for !\n        if(expression.front() == '!')\n            return !parseBoolExpr(in_parentheses); \n\n\n        //else we have & or |        \n        list<bool> values = deduceBoolList(in_parentheses);\n        auto operation = expression.front() == '&' ? \n                         (fbbb)bit_and<bool>() :\n                          bit_or<bool>();\n\n        return std::accumulate(values.begin(), values.end(), values.front(),\n                               operation);\n\n    }\n};\n"
                            }
                        ]
                    },
                    "metadata": {
                        "slug": "parsing-a-boolean-expression",
                        "submissions": {
                            "cpp": "392461518"
                        }
                    }
                }
            ]
        }
    ]
}